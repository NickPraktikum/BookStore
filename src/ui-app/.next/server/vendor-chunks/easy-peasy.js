"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/easy-peasy";
exports.ids = ["vendor-chunks/easy-peasy"];
exports.modules = {

/***/ "(ssr)/./node_modules/easy-peasy/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/easy-peasy/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StoreProvider: () => (/* binding */ StoreProvider),\n/* harmony export */   action: () => (/* binding */ action),\n/* harmony export */   actionOn: () => (/* binding */ actionOn),\n/* harmony export */   computed: () => (/* binding */ computed),\n/* harmony export */   createContextStore: () => (/* binding */ createContextStore),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   createStoreActionsHook: () => (/* binding */ createStoreActionsHook),\n/* harmony export */   createStoreDispatchHook: () => (/* binding */ createStoreDispatchHook),\n/* harmony export */   createStoreRehydratedHook: () => (/* binding */ createStoreRehydratedHook),\n/* harmony export */   createStoreStateHook: () => (/* binding */ createStoreStateHook),\n/* harmony export */   createTransform: () => (/* binding */ createTransform),\n/* harmony export */   createTypedHooks: () => (/* binding */ createTypedHooks),\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   effectOn: () => (/* binding */ effectOn),\n/* harmony export */   generic: () => (/* binding */ generic),\n/* harmony export */   initializeUseStoreState: () => (/* binding */ initializeUseStoreState),\n/* harmony export */   persist: () => (/* binding */ persist),\n/* harmony export */   reducer: () => (/* binding */ reducer),\n/* harmony export */   thunk: () => (/* binding */ thunk),\n/* harmony export */   thunkOn: () => (/* binding */ thunkOn),\n/* harmony export */   useLocalStore: () => (/* binding */ useLocalStore),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreActions: () => (/* binding */ useStoreActions),\n/* harmony export */   useStoreDispatch: () => (/* binding */ useStoreDispatch),\n/* harmony export */   useStoreRehydrated: () => (/* binding */ useStoreRehydrated),\n/* harmony export */   useStoreState: () => (/* binding */ useStoreState)\n/* harmony export */ });\n/* harmony import */ var use_sync_external_store_shim_with_selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/es/index.js\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.esm.mjs\");\n/* harmony import */ var fast_deep_equal_es6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fast-deep-equal/es6 */ \"(ssr)/./node_modules/fast-deep-equal/es6/index.js\");\n/* harmony import */ var fast_deep_equal_es6__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal_es6__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\nvar StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nvar useNotInitialized = function useNotInitialized() {\n    throw new Error(\"uSES not initialized!\");\n};\nvar useSyncExternalStoreWithSelector = useNotInitialized;\nvar initializeUseStoreState = function initializeUseStoreState(fn) {\n    useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = function refEquality(a, b) {\n    return a === b;\n};\nfunction createStoreStateHook(Context) {\n    return function useStoreState(mapState, equalityFn) {\n        if (equalityFn === void 0) {\n            equalityFn = refEquality;\n        }\n        if (true) {\n            if (!mapState) {\n                throw new Error(\"You must pass a selector to useStoreState\");\n            }\n            if (typeof mapState !== \"function\") {\n                throw new Error(\"You must pass a function as a selector to useStoreState\");\n            }\n            if (typeof equalityFn !== \"function\") {\n                throw new Error(\"You must pass a function as an equality function to useStoreState\");\n            }\n        }\n        var store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Context);\n        /*\r\n    function useSyncExternalStoreWithSelector<Snapshot, Selection>(\r\n        subscribe: (onStoreChange: () => void) => () => void,\r\n        getSnapshot: () => Snapshot,\r\n        getServerSnapshot: undefined | null | (() => Snapshot),\r\n        selector: (snapshot: Snapshot) => Selection,\r\n        isEqual?: (a: Selection, b: Selection) => boolean,\r\n    ): Selection;\r\n    */ var selectedState = useSyncExternalStoreWithSelector(store.subscribe, store.getState, store.getState, // getServerSnapshot = getState\n        mapState, equalityFn);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(selectedState);\n        return selectedState;\n    };\n}\nvar useStoreState = createStoreStateHook(StoreContext);\nfunction createStoreActionsHook(Context) {\n    return function useStoreActions(mapActions) {\n        var store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Context);\n        return mapActions(store.getActions());\n    };\n}\nvar useStoreActions = createStoreActionsHook(StoreContext);\nfunction createStoreDispatchHook(Context) {\n    return function useStoreDispatch() {\n        var store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Context);\n        return store.dispatch;\n    };\n}\nvar useStoreDispatch = createStoreDispatchHook(StoreContext);\nfunction useStore() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n}\nfunction createStoreRehydratedHook(Context) {\n    return function useStoreRehydrated() {\n        var store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Context);\n        var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), rehydrated = _useState[0], setRehydrated = _useState[1];\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            store.persist.resolveRehydration().then(function() {\n                return setRehydrated(true);\n            });\n        }, []);\n        return rehydrated;\n    };\n}\nvar useStoreRehydrated = createStoreRehydratedHook(StoreContext);\nfunction createTypedHooks() {\n    return {\n        useStoreActions: useStoreActions,\n        useStoreDispatch: useStoreDispatch,\n        useStoreState: useStoreState,\n        useStoreRehydrated: useStoreRehydrated,\n        useStore: useStore\n    };\n}\nvar actionSymbol = \"$_a\";\nvar actionOnSymbol = \"$_aO\";\nvar computedSymbol = \"$_c\";\nvar effectOnSymbol = \"$_e\";\nvar persistSymbol = \"$_p\";\nvar reducerSymbol = \"$_r\";\nvar thunkOnSymbol = \"$_tO\";\nvar thunkSymbol = \"$_t\";\nvar debug = function debug(state) {\n    if ((0,immer__WEBPACK_IMPORTED_MODULE_4__.isDraft)(state)) {\n        return (0,immer__WEBPACK_IMPORTED_MODULE_4__.current)(state);\n    }\n    return state;\n};\nvar actionOn = function actionOn(targetResolver, fn, config) {\n    var _ref;\n    return _ref = {}, _ref[actionOnSymbol] = true, _ref.fn = fn, _ref.targetResolver = targetResolver, _ref.config = config, _ref;\n};\nvar action = function action(fn, config) {\n    var _ref2;\n    return _ref2 = {}, _ref2[actionSymbol] = true, _ref2.fn = fn, _ref2.config = config, _ref2;\n};\nvar defaultStateResolvers = [\n    function(state) {\n        return state;\n    }\n];\nvar computed = function computed(fnOrStateResolvers, fn) {\n    var _ref4;\n    if (typeof fn === \"function\") {\n        var _ref3;\n        return _ref3 = {}, _ref3[computedSymbol] = true, _ref3.fn = fn, _ref3.stateResolvers = fnOrStateResolvers, _ref3;\n    }\n    return _ref4 = {}, _ref4[computedSymbol] = true, _ref4.fn = fnOrStateResolvers, _ref4.stateResolvers = defaultStateResolvers, _ref4;\n};\nfunction effectOn(dependencyResolvers, fn) {\n    var _ref5;\n    return _ref5 = {}, _ref5[effectOnSymbol] = true, _ref5.dependencyResolvers = dependencyResolvers, _ref5.fn = fn, _ref5;\n}\nfunction generic(value) {\n    return value;\n}\nvar persist = function persist(model, config) {\n    var _objectSpread2;\n    return(// if we are not running in a browser context this becomes a no-op\n     true ? model : 0);\n};\nvar thunkOn = function thunkOn(targetResolver, fn) {\n    var _ref6;\n    return _ref6 = {}, _ref6[thunkOnSymbol] = true, _ref6.fn = fn, _ref6.targetResolver = targetResolver, _ref6;\n};\nvar thunk = function thunk(fn) {\n    var _ref7;\n    return _ref7 = {}, _ref7[thunkSymbol] = true, _ref7.fn = fn, _ref7;\n};\nvar reducer = function reducer(fn, config) {\n    var _ref8;\n    return _ref8 = {}, _ref8[reducerSymbol] = true, _ref8.fn = fn, _ref8.config = config, _ref8;\n};\n/**\r\n * We create our own immer instance to avoid potential issues with autoFreeze\r\n * becoming default enabled everywhere. We want to disable autofreeze as it\r\n * does not suit the design of Easy Peasy.\r\n * https://github.com/immerjs/immer/issues/681#issuecomment-705581111\r\n */ var easyPeasyImmer;\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    var proto = obj;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto;\n}\nfunction clone(source) {\n    function recursiveClone(current) {\n        var next = Object.keys(current).reduce(function(acc, key) {\n            if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n                acc[key] = current[key];\n            }\n            return acc;\n        }, {});\n        Object.keys(next).forEach(function(key) {\n            if (isPlainObject(next[key])) {\n                next[key] = recursiveClone(next[key]);\n            }\n        });\n        return next;\n    }\n    return recursiveClone(source);\n}\nfunction isPromise(x) {\n    return x != null && typeof x === \"object\" && typeof x.then === \"function\";\n}\nfunction get(path, target) {\n    return path.reduce(function(acc, cur) {\n        return isPlainObject(acc) ? acc[cur] : undefined;\n    }, target);\n}\nfunction newify(currentPath, currentState, finalValue) {\n    if (currentPath.length === 0) {\n        return finalValue;\n    }\n    var newState = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, currentState);\n    var key = currentPath[0];\n    if (currentPath.length === 1) {\n        newState[key] = finalValue;\n    } else {\n        newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n    }\n    return newState;\n}\nfunction set(path, target, value) {\n    if (path.length === 0) {\n        if (typeof value === \"object\") {\n            Object.keys(target).forEach(function(key) {\n                delete target[key];\n            });\n            Object.keys(value).forEach(function(key) {\n                target[key] = value[key];\n            });\n        }\n        return;\n    }\n    path.reduce(function(acc, cur, idx) {\n        if (idx + 1 === path.length) {\n            acc[cur] = value;\n        } else {\n            acc[cur] = acc[cur] || {};\n        }\n        return acc[cur];\n    }, target);\n}\nfunction createSimpleProduce(disableImmer) {\n    if (disableImmer === void 0) {\n        disableImmer = false;\n    }\n    return function simpleProduce(path, state, fn, config) {\n        if (config && \"immer\" in config ? (config == null ? void 0 : config.immer) === false : disableImmer) {\n            var _current = get(path, state);\n            var next = fn(_current);\n            if (_current !== next) {\n                return newify(path, state, next);\n            }\n            return state;\n        }\n        if (!easyPeasyImmer) {\n            easyPeasyImmer = new immer__WEBPACK_IMPORTED_MODULE_4__.Immer({\n                // We need to ensure that we disable proxies if they aren't available\n                // on the environment. Users need to ensure that they use the enableES5\n                // feature of immer.\n                useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n                // Autofreezing breaks easy-peasy, we need a mixed version of immutability\n                // and mutability in order to apply updates to our computed properties\n                autoFreeze: false\n            });\n        }\n        if (path.length === 0) {\n            var _draft = easyPeasyImmer.createDraft(state);\n            var _result = fn(_draft);\n            if (_result) {\n                return (0,immer__WEBPACK_IMPORTED_MODULE_4__.isDraft)(_result) ? easyPeasyImmer.finishDraft(_result) : _result;\n            }\n            return easyPeasyImmer.finishDraft(_draft);\n        }\n        var parentPath = path.slice(0, path.length - 1);\n        var draft = easyPeasyImmer.createDraft(state);\n        var parent = get(parentPath, state);\n        var current = get(path, draft);\n        var result = fn(current);\n        if (result) {\n            parent[path[path.length - 1]] = result;\n        }\n        return easyPeasyImmer.finishDraft(draft);\n    };\n}\nvar pReduce = function pReduce(iterable, reducer, initialValue) {\n    return new Promise(function(resolve, reject) {\n        var iterator = iterable[Symbol.iterator]();\n        var index = 0;\n        var next = function next(total) {\n            var element = iterator.next();\n            if (element.done) {\n                resolve(total);\n                return;\n            }\n            Promise.all([\n                total,\n                element.value\n            ]).then(function(value) {\n                return(// eslint-disable-next-line no-plusplus\n                next(reducer(value[0], value[1], index++)));\n            }).catch(function(err) {\n                return reject(err);\n            });\n        };\n        next(initialValue);\n    });\n};\nvar pSeries = function pSeries(tasks) {\n    var results = [];\n    return pReduce(tasks, function(_, task) {\n        return task().then(function(value) {\n            results.push(value);\n        });\n    }).then(function() {\n        return results;\n    });\n};\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for(var i = 0; i < newInputs.length; i += 1){\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction useMemoOne(// getResult changes on every call,\ngetResult, // the inputs array changes on every call\ninputs) {\n    // using useState to generate initial value as it is lazy\n    var initial = react__WEBPACK_IMPORTED_MODULE_1___default().useState(function() {\n        return {\n            inputs: inputs,\n            result: getResult()\n        };\n    })[0];\n    var committed = react__WEBPACK_IMPORTED_MODULE_1___default().useRef(initial);\n    // persist any uncommitted changes after they have been committed\n    var isInputMatch = Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));\n    // create a new cache if required\n    var cache = isInputMatch ? committed.current : {\n        inputs: inputs,\n        result: getResult()\n    };\n    // commit the cache\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(function() {\n        committed.current = cache;\n    }, [\n        cache\n    ]);\n    return cache.result;\n}\nfunction createReducer(disableImmer, _aRD, _cR, _cP) {\n    var simpleProduce = createSimpleProduce(disableImmer);\n    var runActionReducerAtPath = function runActionReducerAtPath(state, action, actionReducer, path, config) {\n        return simpleProduce(path, state, function(draft) {\n            return actionReducer(draft, action.payload);\n        }, config);\n    };\n    var reducerForActions = function reducerForActions(state, action) {\n        var actionReducer = _aRD[action.type];\n        if (actionReducer) {\n            return runActionReducerAtPath(state, action, actionReducer, actionReducer.def.meta.parent, actionReducer.def.config);\n        }\n        return state;\n    };\n    var reducerForCustomReducers = function reducerForCustomReducers(state, action) {\n        return _cR.reduce(function(acc, _ref) {\n            var parentPath = _ref.parentPath, key = _ref.key, reducer = _ref.reducer, config = _ref.config;\n            return simpleProduce(parentPath, acc, function(draft) {\n                draft[key] = reducer((0,immer__WEBPACK_IMPORTED_MODULE_4__.isDraft)(draft[key]) ? (0,immer__WEBPACK_IMPORTED_MODULE_4__.original)(draft[key]) : draft[key], action);\n                return draft;\n            }, config);\n        }, state);\n    };\n    var rootReducer = function rootReducer(state, action) {\n        var stateAfterActions = reducerForActions(state, action);\n        var next = _cR.length > 0 ? reducerForCustomReducers(stateAfterActions, action) : stateAfterActions;\n        if (state !== next) {\n            _cP.forEach(function(_ref2) {\n                var parentPath = _ref2.parentPath, bindComputedProperty = _ref2.bindComputedProperty;\n                var parentState = get(parentPath, next);\n                if (parentState != null) bindComputedProperty(parentState, next);\n            });\n        }\n        return next;\n    };\n    return rootReducer;\n}\nvar migrate = function migrate(data, migrations) {\n    var _data$_migrationVersi;\n    (0,immer__WEBPACK_IMPORTED_MODULE_4__.setAutoFreeze)(false);\n    var version = (_data$_migrationVersi = data._migrationVersion) != null ? _data$_migrationVersi : 0;\n    var toVersion = migrations.migrationVersion;\n    if (typeof version !== \"number\" || typeof toVersion !== \"number\") {\n        throw new Error(\"No migration version found\");\n    }\n    while(version < toVersion){\n        var nextVersion = version + 1;\n        var migrator = migrations[nextVersion];\n        if (!migrator) {\n            throw new Error(\"No migrator found for `migrationVersion` \" + nextVersion);\n        }\n        data = (0,immer__WEBPACK_IMPORTED_MODULE_4__.produce)(data, migrator);\n        data._migrationVersion = nextVersion;\n        version = data._migrationVersion;\n    }\n    (0,immer__WEBPACK_IMPORTED_MODULE_4__.setAutoFreeze)(true);\n    return data;\n};\nvar noopStorage = {\n    getItem: function getItem() {\n        return undefined;\n    },\n    setItem: function setItem() {\n        return undefined;\n    },\n    removeItem: function removeItem() {\n        return undefined;\n    }\n};\nvar getBrowerStorage = function getBrowerStorage(storageName) {\n    var storageCache;\n    return function() {\n        if (!storageCache) {\n            try {\n                if (false) {}\n            } catch (_) {\n            // swallow the failure\n            }\n            if (!storageCache) {\n                storageCache = noopStorage;\n            }\n        }\n        return storageCache;\n    };\n};\nvar localStorage = getBrowerStorage(\"localStorage\");\nvar sessionStorage = getBrowerStorage(\"sessionStorage\");\nfunction createStorageWrapper(storage, transformers, migrations) {\n    if (transformers === void 0) {\n        transformers = [];\n    }\n    if (migrations === void 0) {\n        migrations = {};\n    }\n    if (storage == null) {\n        storage = sessionStorage();\n    }\n    if (typeof storage === \"string\") {\n        if (storage === \"localStorage\") {\n            storage = localStorage();\n        } else if (storage === \"sessionStorage\") {\n            storage = sessionStorage();\n        } else {\n            if (true) {\n                // eslint-disable-next-line no-console\n                console.warn(\"Invalid storage provider\");\n            }\n            storage = noopStorage;\n        }\n    }\n    var outTransformers = [].concat(transformers).reverse();\n    var serialize = function serialize(data) {\n        if (transformers.length > 0 && data != null && typeof data === \"object\") {\n            Object.keys(data).forEach(function(key) {\n                data[key] = transformers.reduce(function(acc, cur) {\n                    return cur.in(acc, key, data);\n                }, data[key]);\n            });\n        }\n        return storage === localStorage() || storage === sessionStorage() ? JSON.stringify({\n            data: data\n        }) : data;\n    };\n    var deserialize = function deserialize(data) {\n        var storageData = storage === localStorage() || storage === sessionStorage() ? JSON.parse(data).data : data;\n        var hasMigrations = Object.keys(migrations).length > 0;\n        var result = hasMigrations ? migrate(storageData, migrations) : storageData;\n        if (outTransformers.length > 0 && result != null && typeof result === \"object\") {\n            Object.keys(result).forEach(function(key) {\n                result[key] = outTransformers.reduce(function(acc, cur) {\n                    return cur.out(acc, key, result);\n                }, result[key]);\n            });\n        }\n        return result;\n    };\n    var isAsync = isPromise(storage.getItem(\"_\"));\n    return {\n        getItem: function getItem(key) {\n            if (isAsync) {\n                return storage.getItem(key).then(function(wrapped) {\n                    return wrapped != null ? deserialize(wrapped) : undefined;\n                });\n            }\n            var wrapped = storage.getItem(key);\n            return wrapped != null ? deserialize(wrapped) : undefined;\n        },\n        setItem: function setItem(key, data) {\n            return storage.setItem(key, serialize(data));\n        },\n        removeItem: function removeItem(key) {\n            return storage.removeItem(key);\n        }\n    };\n}\nfunction extractPersistConfig(path, persistdef) {\n    if (persistdef === void 0) {\n        persistdef = {};\n    }\n    return {\n        path: path,\n        config: {\n            allow: persistdef.allow || [],\n            deny: persistdef.deny || [],\n            mergeStrategy: persistdef.mergeStrategy || \"mergeDeep\",\n            storage: createStorageWrapper(persistdef.storage, persistdef.transformers, persistdef.migrations)\n        }\n    };\n}\nfunction resolvePersistTargets(target, allow, deny) {\n    var targets = Object.keys(target);\n    if (allow.length > 0) {\n        targets = targets.reduce(function(acc, cur) {\n            if (allow.findIndex(function(x) {\n                return x === cur;\n            }) !== -1) {\n                return [].concat(acc, [\n                    cur\n                ]);\n            }\n            return acc;\n        }, []);\n    }\n    if (deny.length > 0) {\n        targets = targets.reduce(function(acc, cur) {\n            if (deny.findIndex(function(x) {\n                return x === cur;\n            }) !== -1) {\n                return acc;\n            }\n            return [].concat(acc, [\n                cur\n            ]);\n        }, []);\n    }\n    return targets;\n}\nfunction createPersistenceClearer(persistKey, _r) {\n    return function() {\n        if (_r._i._persistenceConfig.length === 0) {\n            return Promise.resolve();\n        }\n        return pSeries(_r._i._persistenceConfig.map(function(_ref) {\n            var path = _ref.path, config = _ref.config;\n            return function() {\n                return Promise.resolve(config.storage.removeItem(persistKey(path)));\n            };\n        }));\n    };\n}\nfunction createPersistor(persistKey, _r) {\n    var persistPromise = Promise.resolve();\n    var isPersisting = false;\n    var nextPersistOperation;\n    var timingMethod =  true ? function(fn) {\n        return fn();\n    } : 0;\n    var persist = function persist(nextState) {\n        if (_r._i._persistenceConfig.length === 0) {\n            return;\n        }\n        var operation = function operation() {\n            isPersisting = true;\n            persistPromise = new Promise(function(resolve) {\n                timingMethod(function() {\n                    pSeries(_r._i._persistenceConfig.map(function(_ref2) {\n                        var path = _ref2.path, config = _ref2.config;\n                        return function() {\n                            var storage = config.storage, allow = config.allow, deny = config.deny;\n                            var persistRootState = clone(get(path, nextState));\n                            var persistTargets = resolvePersistTargets(persistRootState, allow, deny);\n                            var stateToPersist = {};\n                            persistTargets.map(function(key) {\n                                var targetPath = [].concat(path, [\n                                    key\n                                ]);\n                                var rawValue = get(targetPath, nextState);\n                                var value = isPlainObject(rawValue) ? clone(rawValue) : rawValue;\n                                stateToPersist[key] = value;\n                            });\n                            return Promise.resolve(storage.setItem(persistKey(path), stateToPersist));\n                        };\n                    })).finally(function() {\n                        isPersisting = false;\n                        if (nextPersistOperation) {\n                            var next = nextPersistOperation;\n                            nextPersistOperation = null;\n                            next();\n                        } else {\n                            resolve();\n                        }\n                    });\n                });\n            });\n        };\n        if (isPersisting) {\n            nextPersistOperation = operation;\n        } else {\n            operation();\n        }\n    };\n    return {\n        persist: persist,\n        clear: createPersistenceClearer(persistKey, _r),\n        flush: function flush() {\n            if (nextPersistOperation) {\n                nextPersistOperation();\n            }\n            return persistPromise;\n        }\n    };\n}\nfunction createPersistMiddleware(persistor, _r) {\n    return function(_ref3) {\n        var getState = _ref3.getState;\n        return function(next) {\n            return function(action) {\n                var state = next(action);\n                if (action && action.type !== \"@action.ePRS\" && _r._i._persistenceConfig.length > 0) {\n                    persistor.persist(getState());\n                }\n                return state;\n            };\n        };\n    };\n}\nfunction rehydrateStateFromPersistIfNeeded(persistKey, replaceState, _r, root) {\n    if (_r._i._persistenceConfig.length === 0) {\n        return Promise.resolve();\n    }\n    var state = clone(_r._i._dS);\n    var rehydrating = false;\n    return pSeries(_r._i._persistenceConfig.map(function(persistInstance) {\n        return function() {\n            var path = persistInstance.path, config = persistInstance.config;\n            var mergeStrategy = config.mergeStrategy, storage = config.storage;\n            if (root && (path.length < 1 || path[0] !== root)) {\n                return Promise.resolve();\n            }\n            var hasDataModelChanged = function hasDataModelChanged(dataModel, rehydratingModelData) {\n                return dataModel != null && rehydratingModelData != null && (typeof dataModel !== typeof rehydratingModelData || Array.isArray(dataModel) && !Array.isArray(rehydratingModelData));\n            };\n            var applyRehydrationStrategy = function applyRehydrationStrategy(persistedState) {\n                if (mergeStrategy === \"overwrite\") {\n                    set(path, state, persistedState);\n                } else if (mergeStrategy === \"mergeShallow\") {\n                    var targetState = get(path, state);\n                    Object.keys(persistedState).forEach(function(key) {\n                        if (hasDataModelChanged(targetState[key], persistedState[key])) ;\n                        else {\n                            targetState[key] = persistedState[key];\n                        }\n                    });\n                } else if (mergeStrategy === \"mergeDeep\") {\n                    var _targetState = get(path, state);\n                    var setAt = function setAt(currentTargetState, currentPersistedState) {\n                        Object.keys(currentPersistedState).forEach(function(key) {\n                            if (hasDataModelChanged(currentTargetState[key], currentPersistedState[key])) ;\n                            else if (isPlainObject(currentPersistedState[key])) {\n                                currentTargetState[key] = currentTargetState[key] || {};\n                                setAt(currentTargetState[key], currentPersistedState[key]);\n                            } else {\n                                currentTargetState[key] = currentPersistedState[key];\n                            }\n                        });\n                    };\n                    setAt(_targetState, persistedState);\n                }\n            };\n            var rehydate = function rehydate(persistedState) {\n                if (persistedState != null) {\n                    applyRehydrationStrategy(persistedState);\n                    rehydrating = true;\n                }\n            };\n            var getItemResult = storage.getItem(persistKey(path));\n            if (isPromise(getItemResult)) {\n                return getItemResult.then(rehydate);\n            }\n            return Promise.resolve(rehydate(getItemResult));\n        };\n    })).then(function() {\n        if (rehydrating) {\n            replaceState(state);\n        }\n    });\n}\nfunction createActionCreator(def, _r) {\n    function actionCreator(payload) {\n        var action = {\n            type: def.meta.type,\n            payload: payload,\n            config: def.config\n        };\n        if (def[actionOnSymbol] && def.meta.resolvedTargets) {\n            payload.resolvedTargets = [].concat(def.meta.resolvedTargets);\n        }\n        return _r.dispatch(action);\n    }\n    // We bind the types to the creator for easy reference by consumers\n    actionCreator.type = def.meta.type;\n    return actionCreator;\n}\nfunction createThunkHandler(def, _r, injections, _aC) {\n    return function(payload, fail) {\n        var helpers = {\n            dispatch: _r.dispatch,\n            fail: fail,\n            getState: function getState() {\n                return get(def.meta.parent, _r.getState());\n            },\n            getStoreActions: function getStoreActions() {\n                return _aC;\n            },\n            getStoreState: _r.getState,\n            injections: injections,\n            meta: {\n                key: def.meta.actionName,\n                parent: def.meta.parent,\n                path: def.meta.path\n            }\n        };\n        if (def[thunkOnSymbol] && def.meta.resolvedTargets) {\n            payload.resolvedTargets = [].concat(def.meta.resolvedTargets);\n        }\n        return def.fn(get(def.meta.parent, _aC), payload, helpers);\n    };\n}\nvar logThunkEventListenerError = function logThunkEventListenerError(type, err) {\n    // eslint-disable-next-line no-console\n    console.log(\"Error in \" + type);\n    // eslint-disable-next-line no-console\n    console.log(err);\n};\nvar handleEventDispatchErrors$1 = function handleEventDispatchErrors(type, dispatcher) {\n    return function() {\n        try {\n            var result = dispatcher.apply(void 0, arguments);\n            if (isPromise(result)) {\n                result.catch(function(err) {\n                    logThunkEventListenerError(type, err);\n                });\n            }\n        } catch (err) {\n            logThunkEventListenerError(type, err);\n        }\n    };\n};\nfunction createThunkActionsCreator(def, _r) {\n    var actionCreator = function actionCreator(payload) {\n        var dispatchStart = handleEventDispatchErrors$1(def.meta.startType, function() {\n            return _r.dispatch({\n                type: def.meta.startType,\n                payload: payload\n            });\n        });\n        var dispatchFail = handleEventDispatchErrors$1(def.meta.failType, function(err) {\n            return _r.dispatch({\n                type: def.meta.failType,\n                payload: payload,\n                error: err\n            });\n        });\n        var dispatchSuccess = handleEventDispatchErrors$1(def.meta.successType, function(result) {\n            return _r.dispatch({\n                type: def.meta.successType,\n                payload: payload,\n                result: result\n            });\n        });\n        dispatchStart();\n        var failure = null;\n        var fail = function fail(_failure) {\n            failure = _failure || new Error();\n        };\n        var result = _r.dispatch(function() {\n            return def.thunkHandler(payload, fail);\n        });\n        if (isPromise(result)) {\n            return result.then(function(resolved) {\n                if (failure) {\n                    dispatchFail(failure);\n                } else {\n                    dispatchSuccess(resolved);\n                }\n                return resolved;\n            });\n        }\n        if (failure) {\n            dispatchFail(failure);\n        } else {\n            dispatchSuccess(result);\n        }\n        return result;\n    };\n    actionCreator.type = def.meta.type;\n    actionCreator.successType = def.meta.successType;\n    actionCreator.failType = def.meta.failType;\n    actionCreator.startType = def.meta.startType;\n    return actionCreator;\n}\nfunction createListenerMiddleware(_r) {\n    return function() {\n        return function(next) {\n            return function(action) {\n                var result = next(action);\n                if (action && _r._i._lAM[action.type] && _r._i._lAM[action.type].length > 0) {\n                    var sourceAction = _r._i._aCD[action.type];\n                    _r._i._lAM[action.type].forEach(function(actionCreator) {\n                        actionCreator({\n                            type: sourceAction ? sourceAction.def.meta.type : action.type,\n                            payload: action.payload,\n                            error: action.error,\n                            result: action.result\n                        });\n                    });\n                }\n                return result;\n            };\n        };\n    };\n}\nfunction bindListenerdefs(listenerdefs, _aC, _aCD, _lAM) {\n    listenerdefs.forEach(function(def) {\n        var targets = def.targetResolver(get(def.meta.parent, _aC), _aC);\n        var targetTypes = (Array.isArray(targets) ? targets : [\n            targets\n        ]).reduce(function(acc, target) {\n            if (typeof target === \"function\" && target.def.meta.type && _aCD[target.def.meta.type]) {\n                if (target.def.meta.successType) {\n                    acc.push(target.def.meta.successType);\n                } else {\n                    acc.push(target.def.meta.type);\n                }\n            } else if (typeof target === \"string\") {\n                acc.push(target);\n            }\n            return acc;\n        }, []);\n        def.meta.resolvedTargets = targetTypes;\n        targetTypes.forEach(function(targetType) {\n            var listenerReg = _lAM[targetType] || [];\n            listenerReg.push(_aCD[def.meta.type]);\n            _lAM[targetType] = listenerReg;\n        });\n    });\n}\nfunction createComputedPropertyBinder(key, def, _r) {\n    var hasRunOnce = false;\n    var prevInputs = [];\n    var prevValue;\n    var prevStoreState;\n    var performingEqualityCheck = false;\n    var areEqual = function areEqual(a, b) {\n        performingEqualityCheck = true;\n        var result = fast_deep_equal_es6__WEBPACK_IMPORTED_MODULE_3___default()(a, b);\n        performingEqualityCheck = false;\n        return result;\n    };\n    return function createComputedProperty(parentState, storeState) {\n        Object.defineProperty(parentState, key, {\n            configurable: true,\n            enumerable: true,\n            get: function get() {\n                if (performingEqualityCheck) {\n                    return prevValue;\n                }\n                var inputs = def.stateResolvers.map(function(resolver) {\n                    return resolver(parentState, storeState);\n                });\n                if (hasRunOnce && (storeState === prevStoreState && areInputsEqual(inputs, prevInputs) || // We don't want computed properties resolved every time an action\n                // is handled by the reducer. They need to remain lazy, only being\n                // computed when used by a component or getState call;\n                _r._i._cS.isInReducer && // This is to account for strange errors that may occur via immer;\n                new Error().stack.match(/shallowCopy/gi) !== null)) {\n                    return prevValue;\n                }\n                var newValue = def.fn.apply(def, inputs);\n                if (!areEqual(newValue, prevValue)) {\n                    prevValue = newValue;\n                }\n                prevInputs = inputs;\n                prevStoreState = storeState;\n                hasRunOnce = true;\n                return prevValue;\n            }\n        });\n    };\n}\nfunction createComputedPropertiesMiddleware(_r) {\n    return function() {\n        return function(next) {\n            return function(action) {\n                _r._i._cS.isInReducer = true;\n                var result = next(action);\n                _r._i._cS.isInReducer = false;\n                return result;\n            };\n        };\n    };\n}\nfunction createEffectsMiddleware(_r) {\n    return function(store) {\n        return function(next) {\n            return function(action) {\n                if (_r._i._e.length === 0) {\n                    return next(action);\n                }\n                var prevState = store.getState();\n                var result = next(action);\n                var nextState = store.getState();\n                if (prevState !== nextState) {\n                    _r._i._e.forEach(function(def) {\n                        var prevLocal = get(def.meta.parent, prevState);\n                        var nextLocal = get(def.meta.parent, nextState);\n                        var prevDependencies = def.dependencyResolvers.map(function(resolver) {\n                            return resolver(prevLocal, prevState);\n                        });\n                        var nextDependencies = def.dependencyResolvers.map(function(resolver) {\n                            return resolver(nextLocal, nextState);\n                        });\n                        var hasChanged = prevDependencies.some(function(dependency, idx) {\n                            return dependency !== nextDependencies[idx];\n                        });\n                        if (hasChanged) {\n                            def.actionCreator(prevDependencies, nextDependencies, action);\n                        }\n                    });\n                }\n                return result;\n            };\n        };\n    };\n}\nvar logEffectError = function logEffectError(err) {\n    // As users can't get a handle on effects we need to report the error\n    // eslint-disable-next-line no-console\n    console.error(err);\n};\nfunction createEffectHandler(def, _r, injections, _aC) {\n    var dispose;\n    return function(change) {\n        var helpers = {\n            dispatch: _r.dispatch,\n            getState: function getState() {\n                return get(def.meta.parent, _r.getState());\n            },\n            getStoreActions: function getStoreActions() {\n                return _aC;\n            },\n            getStoreState: _r.getState,\n            injections: injections,\n            meta: {\n                key: def.meta.actionName,\n                parent: def.meta.parent,\n                path: def.meta.path\n            }\n        };\n        if (dispose !== undefined) {\n            var disposeResult = dispose();\n            dispose = undefined;\n            if (isPromise(disposeResult)) {\n                disposeResult.catch(logEffectError);\n            }\n        }\n        var actions = get(def.meta.parent, _aC);\n        var effectResult = def.fn(actions, change, helpers);\n        if (isPromise(effectResult)) {\n            return effectResult.then(function(resolved) {\n                if (typeof resolved === \"function\") {\n                    if (true) {\n                        // Dispose functions are not allowed to be resolved asynchronously.\n                        // Doing so would provide inconsistent behaviour around their execution.\n                        // eslint-disable-next-line no-console\n                        console.warn(\"[easy-peasy] Effect is asynchronously resolving a dispose fn.\");\n                    }\n                }\n            });\n        }\n        if (typeof effectResult === \"function\") {\n            dispose = effectResult;\n        }\n        return undefined;\n    };\n}\nvar logEffectEventListenerError = function logEffectEventListenerError(type, err) {\n    // eslint-disable-next-line no-console\n    console.log(\"Error in \" + type);\n    // eslint-disable-next-line no-console\n    console.log(err);\n};\nvar handleEventDispatchErrors = function handleEventDispatchErrors(type, dispatcher) {\n    return function() {\n        try {\n            var result = dispatcher.apply(void 0, arguments);\n            if (isPromise(result)) {\n                result.catch(function(err) {\n                    logEffectEventListenerError(type, err);\n                });\n            }\n        } catch (err) {\n            logEffectEventListenerError(type, err);\n        }\n    };\n};\nfunction createEffectActionsCreator(def, _r, effectHandler) {\n    var actionCreator = function actionCreator(previousDependencies, nextDependencies, action) {\n        var change = {\n            prev: previousDependencies,\n            current: nextDependencies,\n            action: action\n        };\n        var dispatchStart = handleEventDispatchErrors(def.meta.startType, function() {\n            return _r.dispatch({\n                type: def.meta.startType,\n                change: change\n            });\n        });\n        var dispatchSuccess = handleEventDispatchErrors(def.meta.successType, function() {\n            return _r.dispatch({\n                type: def.meta.successType,\n                change: change\n            });\n        });\n        dispatchStart();\n        try {\n            var result = _r.dispatch(function() {\n                return effectHandler(change);\n            });\n            if (isPromise(result)) {\n                return result.then(function(resolved) {\n                    dispatchSuccess(resolved);\n                    return resolved;\n                }, logEffectError);\n            }\n            dispatchSuccess(result);\n            return result;\n        } catch (err) {\n            logEffectError(err);\n        }\n        return undefined;\n    };\n    actionCreator.type = def.meta.type;\n    actionCreator.startType = def.meta.startType;\n    actionCreator.successType = def.meta.successType;\n    actionCreator.failType = def.meta.failType;\n    return actionCreator;\n}\nfunction extractDataFromModel(model, initialState, injections, _r) {\n    var _dS = initialState;\n    var _aCD = {};\n    var _aC = {};\n    var _aRD = {};\n    var actionThunks = {};\n    var _cP = [];\n    var _cR = [];\n    var _e = [];\n    var _lAC = {};\n    var _lAM = {};\n    var listenerdefs = [];\n    var _persistenceConfig = [];\n    var _cS = {\n        isInReducer: false\n    };\n    var recursiveExtractFromModel = function recursiveExtractFromModel(current, parentPath) {\n        return Object.keys(current).forEach(function(key) {\n            var value = current[key];\n            var path = [].concat(parentPath, [\n                key\n            ]);\n            var meta = {\n                parent: parentPath,\n                path: path,\n                key: key\n            };\n            var handleValueAsState = function handleValueAsState() {\n                var initialParentRef = get(parentPath, initialState);\n                if (initialParentRef && key in initialParentRef) {\n                    set(path, _dS, initialParentRef[key]);\n                } else {\n                    set(path, _dS, value);\n                }\n            };\n            if (key === persistSymbol) {\n                _persistenceConfig.push(extractPersistConfig(parentPath, value));\n                return;\n            }\n            if (value != null && typeof value === \"object\") {\n                if (value[actionSymbol] || value[actionOnSymbol]) {\n                    var def = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, value);\n                    // Determine the category of the action\n                    var category = def[actionSymbol] ? \"@action\" : \"@actionOn\";\n                    // Establish the meta data describing the action\n                    def.meta = {\n                        actionName: meta.key,\n                        category: category,\n                        type: category + \".\" + meta.path.join(\".\"),\n                        parent: meta.parent,\n                        path: meta.path\n                    };\n                    // Create the \"action creator\" function\n                    def.actionCreator = createActionCreator(def, _r);\n                    // Create a bidirectional relationship of the def/actionCreator\n                    def.actionCreator.def = def;\n                    // Create a bidirectional relationship of the def/reducer\n                    def.fn.def = def;\n                    // Add the action creator to lookup map\n                    _aCD[def.meta.type] = def.actionCreator;\n                    // Add the reducer to lookup map\n                    _aRD[def.meta.type] = def.fn;\n                    // We don't want to expose the internal action to consumers\n                    if (meta.key !== \"ePRS\") {\n                        // Set the action creator in the \"actions\" object tree for\n                        // either the listeners object tree, or the standard actions/thunks\n                        // object tree\n                        if (def[actionOnSymbol]) {\n                            listenerdefs.push(def);\n                            set(path, _lAC, def.actionCreator);\n                        } else {\n                            set(path, _aC, def.actionCreator);\n                        }\n                    }\n                } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n                    var _def = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, value);\n                    // Determine the category of the thunk\n                    var _category = _def[thunkSymbol] ? \"@thunk\" : \"@thunkOn\";\n                    // Establish the meta data describing the thunk\n                    var type = _category + \".\" + meta.path.join(\".\");\n                    _def.meta = {\n                        actionName: meta.key,\n                        parent: meta.parent,\n                        path: meta.path,\n                        type: type,\n                        startType: type + \"(start)\",\n                        successType: type + \"(success)\",\n                        failType: type + \"(fail)\"\n                    };\n                    // Create the function that will handle, i.e. be executed, when\n                    // the thunk action is created/dispatched\n                    _def.thunkHandler = createThunkHandler(_def, _r, injections, _aC);\n                    // Register the thunk handler\n                    set(path, actionThunks, _def.thunkHandler);\n                    // Create the \"action creator\" function\n                    _def.actionCreator = createThunkActionsCreator(_def, _r);\n                    // Create a bidirectional relationship of the def/actionCreator\n                    _def.actionCreator.def = _def;\n                    // Register the action creator within the lookup map\n                    _aCD[_def.meta.type] = _def.actionCreator;\n                    // Set the action creator in the \"actions\" object tree for\n                    // either the listeners object tree, or the standard actions/thunks\n                    // object tree\n                    if (_def[thunkOnSymbol]) {\n                        listenerdefs.push(_def);\n                        set(path, _lAC, _def.actionCreator);\n                    } else {\n                        set(path, _aC, _def.actionCreator);\n                    }\n                } else if (value[computedSymbol]) {\n                    var parent = get(parentPath, _dS);\n                    var bindComputedProperty = createComputedPropertyBinder(key, value, _r);\n                    bindComputedProperty(parent, _dS);\n                    _cP.push({\n                        key: key,\n                        parentPath: parentPath,\n                        bindComputedProperty: bindComputedProperty\n                    });\n                } else if (value[reducerSymbol]) {\n                    _cR.push({\n                        key: key,\n                        parentPath: parentPath,\n                        reducer: value.fn,\n                        config: value.config\n                    });\n                } else if (value[effectOnSymbol]) {\n                    var _def2 = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, value);\n                    // Establish the meta data describing the effect\n                    var _type = \"@effectOn.\" + meta.path.join(\".\");\n                    _def2.meta = {\n                        type: _type,\n                        actionName: meta.key,\n                        parent: meta.parent,\n                        path: meta.path,\n                        startType: _type + \"(start)\",\n                        successType: _type + \"(success)\",\n                        failType: _type + \"(fail)\"\n                    };\n                    var effectHandler = createEffectHandler(_def2, _r, injections, _aC);\n                    var actionCreator = createEffectActionsCreator(_def2, _r, effectHandler);\n                    _def2.actionCreator = actionCreator;\n                    _e.push(_def2);\n                } else if (isPlainObject(value)) {\n                    var existing = get(path, _dS);\n                    if (existing == null) {\n                        set(path, _dS, {});\n                    }\n                    recursiveExtractFromModel(value, path);\n                } else {\n                    handleValueAsState();\n                }\n            } else {\n                handleValueAsState();\n            }\n        });\n    };\n    _persistenceConfig = _persistenceConfig.sort(function(a, b) {\n        var aPath = a.path.join(\".\");\n        var bPath = b.path.join(\".\");\n        if (aPath < bPath) {\n            return -1;\n        }\n        if (aPath > bPath) {\n            return 1;\n        }\n        return 0;\n    });\n    recursiveExtractFromModel(model, []);\n    bindListenerdefs(listenerdefs, _aC, _aCD, _lAM);\n    return {\n        _aCD: _aCD,\n        _aC: _aC,\n        _aRD: _aRD,\n        _cP: _cP,\n        _cR: _cR,\n        _cS: _cS,\n        _dS: _dS,\n        _e: _e,\n        _lAC: _lAC,\n        _lAM: _lAM,\n        _persistenceConfig: _persistenceConfig\n    };\n}\nfunction createStore(model, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var modelClone = clone(model);\n    var _options = options, compose$1 = _options.compose, _options$devTools = _options.devTools, devTools = _options$devTools === void 0 ? \"development\" !== \"production\" : _options$devTools, _options$disableImmer = _options.disableImmer, disableImmer = _options$disableImmer === void 0 ? false : _options$disableImmer, _options$enhancers = _options.enhancers, enhancers = _options$enhancers === void 0 ? [] : _options$enhancers, _options$initialState = _options.initialState, initialState = _options$initialState === void 0 ? undefined : _options$initialState, _options$injections = _options.injections, injections = _options$injections === void 0 ? {} : _options$injections, _options$middleware = _options.middleware, middleware = _options$middleware === void 0 ? [] : _options$middleware, _options$mockActions = _options.mockActions, mockActions = _options$mockActions === void 0 ? false : _options$mockActions, _options$name = _options.name, storeName = _options$name === void 0 ? \"EasyPeasyStore\" : _options$name, _options$version = _options.version, version = _options$version === void 0 ? 0 : _options$version, _options$reducerEnhan = _options.reducerEnhancer, reducerEnhancer = _options$reducerEnhan === void 0 ? function(rootReducer) {\n        return rootReducer;\n    } : _options$reducerEnhan;\n    var bindReplaceState = function bindReplaceState(modelDef) {\n        return _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, modelDef), {}, {\n            ePRS: action(function(_, payload) {\n                return payload;\n            })\n        });\n    };\n    var _r = {};\n    var modeldef = bindReplaceState(modelClone);\n    var mockedActions = [];\n    var persistKey = function persistKey(targetPath) {\n        return \"[\" + storeName + \"][\" + version + \"]\" + (targetPath.length > 0 ? \"[\" + targetPath.join(\".\") + \"]\" : \"\");\n    };\n    var persistor = createPersistor(persistKey, _r);\n    var persistMiddleware = createPersistMiddleware(persistor, _r);\n    var replaceState = function replaceState(nextState) {\n        return _r._i._aCD[\"@action.ePRS\"](nextState);\n    };\n    var bindStoreInternals = function bindStoreInternals(state) {\n        if (state === void 0) {\n            state = {};\n        }\n        var data = extractDataFromModel(modeldef, state, injections, _r);\n        _r._i = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, data), {}, {\n            reducer: reducerEnhancer(createReducer(disableImmer, data._aRD, data._cR, data._cP))\n        });\n    };\n    var mockActionsMiddleware = function mockActionsMiddleware() {\n        return function() {\n            return function(action) {\n                if (action != null) {\n                    mockedActions.push(action);\n                }\n                return undefined;\n            };\n        };\n    };\n    var devToolConfig = devTools === true ? {} : devTools;\n    var composeEnhancers = compose$1 || (devTools && \"undefined\" !== \"undefined\" && 0 ? 0 : redux__WEBPACK_IMPORTED_MODULE_5__.compose);\n    bindStoreInternals(initialState || {});\n    var easyPeasyMiddleware = [\n        createComputedPropertiesMiddleware(_r)\n    ].concat(middleware, [\n        redux_thunk__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n        createListenerMiddleware(_r),\n        createEffectsMiddleware(_r),\n        persistMiddleware\n    ]);\n    if (mockActions) {\n        easyPeasyMiddleware.push(mockActionsMiddleware);\n    }\n    var store = (0,redux__WEBPACK_IMPORTED_MODULE_5__.createStore)(_r._i.reducer, _r._i._dS, composeEnhancers.apply(void 0, [\n        redux__WEBPACK_IMPORTED_MODULE_5__.applyMiddleware.apply(void 0, easyPeasyMiddleware)\n    ].concat(enhancers)));\n    store.subscribe(function() {\n        _r._i._cS.isInReducer = false;\n    });\n    _r.dispatch = store.dispatch;\n    _r.getState = store.getState;\n    var bindActionCreators = function bindActionCreators() {\n        Object.keys(store.dispatch).forEach(function(actionsKey) {\n            delete store.dispatch[actionsKey];\n        });\n        Object.keys(_r._i._aC).forEach(function(key) {\n            store.dispatch[key] = _r._i._aC[key];\n        });\n    };\n    bindActionCreators();\n    var rebindStore = function rebindStore(removeKey) {\n        var currentState = store.getState();\n        if (removeKey) {\n            delete currentState[removeKey];\n        }\n        bindStoreInternals(currentState);\n        store.replaceReducer(_r._i.reducer);\n        replaceState(_r._i._dS);\n        bindActionCreators();\n    };\n    var _resolveRehydration = rehydrateStateFromPersistIfNeeded(persistKey, replaceState, _r);\n    return Object.assign(store, {\n        addModel: function addModel(key, modelForKey) {\n            if (modeldef[key] && \"development\" !== \"production\") {\n                store.removeModel(key);\n            }\n            modeldef[key] = modelForKey;\n            rebindStore();\n            // There may have been persisted state for a dynamic model. We should try\n            // and rehydrate the specifc node\n            var addModelRehydration = rehydrateStateFromPersistIfNeeded(persistKey, replaceState, _r, key);\n            return {\n                resolveRehydration: function resolveRehydration() {\n                    return addModelRehydration;\n                }\n            };\n        },\n        clearMockedActions: function clearMockedActions() {\n            mockedActions = [];\n        },\n        getActions: function getActions() {\n            return _r._i._aC;\n        },\n        getListeners: function getListeners() {\n            return _r._i._lAC;\n        },\n        getMockedActions: function getMockedActions() {\n            return [].concat(mockedActions);\n        },\n        persist: {\n            clear: persistor.clear,\n            flush: persistor.flush,\n            resolveRehydration: function resolveRehydration() {\n                return _resolveRehydration;\n            }\n        },\n        reconfigure: function reconfigure(newModel) {\n            modeldef = bindReplaceState(newModel);\n            rebindStore();\n        },\n        removeModel: function removeModel(key) {\n            if (!modeldef[key]) {\n                return;\n            }\n            delete modeldef[key];\n            rebindStore(key);\n        }\n    });\n}\nfunction createContextStore(model, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    // We create a mutable injections reference to allow updating it\n    var _config = config, _config$injections = _config.injections, mutableInjections = _config$injections === void 0 ? {} : _config$injections;\n    var StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\n    function Provider(_ref) {\n        var children = _ref.children, runtimeModel = _ref.runtimeModel, injections = _ref.injections;\n        // If the user provided injections we need to ensure our mutable ref\n        // is up to date. We could consider doing a shallow compare here?\n        if (injections != null) {\n            var nextInjections = typeof injections === \"function\" ? injections(mutableInjections) : injections;\n            var nextKeys = Object.keys(nextInjections);\n            var removeKeys = Object.keys(mutableInjections).filter(function(k) {\n                return !nextKeys.includes(k);\n            });\n            removeKeys.forEach(function(k) {\n                delete mutableInjections[k];\n            });\n            Object.assign(mutableInjections, nextInjections);\n        }\n        var store = useMemoOne(function() {\n            return createStore(typeof model === \"function\" ? model(runtimeModel) : model, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, config), {}, {\n                originalInjections: mutableInjections\n            }));\n        }, []);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(StoreContext.Provider, {\n            value: store\n        }, children);\n    }\n    function useStore() {\n        return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    }\n    return {\n        Provider: Provider,\n        useStore: useStore,\n        useStoreState: createStoreStateHook(StoreContext),\n        useStoreActions: createStoreActionsHook(StoreContext),\n        useStoreDispatch: createStoreDispatchHook(StoreContext),\n        useStoreRehydrated: createStoreRehydratedHook(StoreContext)\n    };\n}\n/**\r\n * This file has been copied from redux-persist.\r\n * The intention being to support as much of the redux-persist API as possible.\r\n */ function createTransform(inbound, outbound, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    var whitelist = config.whitelist || null;\n    var blacklist = config.blacklist || null;\n    function whitelistBlacklistCheck(key) {\n        if (whitelist && whitelist.indexOf(key) === -1) return true;\n        if (blacklist && blacklist.indexOf(key) !== -1) return true;\n        return false;\n    }\n    return {\n        in: function _in(data, key, fullState) {\n            return !whitelistBlacklistCheck(key) && inbound ? inbound(data, key, fullState) : data;\n        },\n        out: function out(data, key, fullState) {\n            return !whitelistBlacklistCheck(key) && outbound ? outbound(data, key, fullState) : data;\n        }\n    };\n}\n/* eslint-disable react/prop-types */ function StoreProvider(_ref) {\n    var children = _ref.children, store = _ref.store;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(StoreContext.Provider, {\n        value: store\n    }, children);\n}\nfunction useLocalStore(modelCreator, dependencies, configCreator) {\n    if (dependencies === void 0) {\n        dependencies = [];\n    }\n    if (configCreator === void 0) {\n        configCreator = null;\n    }\n    var storeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    var configRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    var store = useMemoOne(function() {\n        var previousState = storeRef.current != null ? storeRef.current.getState() : undefined;\n        var config = configCreator != null ? configCreator(previousState, configRef.current) : undefined;\n        var _store = createStore(modelCreator(previousState), config);\n        configRef.current = config;\n        storeRef.current = _store;\n        return _store;\n    }, dependencies);\n    var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(function() {\n        return store.getState();\n    }), currentState = _useState[0], setCurrentState = _useState[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        setCurrentState(store.getState());\n        store.subscribe(function() {\n            var nextState = store.getState();\n            if (currentState !== nextState) {\n                setCurrentState(nextState);\n            }\n        });\n    }, [\n        store\n    ]);\n    return [\n        currentState,\n        store.getActions(),\n        store\n    ];\n}\n// React 18 requires the use of the useSyncExternalStore hook for external\ninitializeUseStoreState(use_sync_external_store_shim_with_selector__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStoreWithSelector);\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeS1wZWFzeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvSTtBQUMvQjtBQUNwQztBQUNjO0FBQzFDO0FBQzZDO0FBQzFDO0FBRXhDLElBQUlzQiw2QkFBZW5CLG9EQUFhQTtBQUVoQyxJQUFJb0Isb0JBQW9CLFNBQVNBO0lBQy9CLE1BQU0sSUFBSUMsTUFBTTtBQUNsQjtBQUNBLElBQUl4QixtQ0FBbUN1QjtBQUN2QyxJQUFJRSwwQkFBMEIsU0FBU0Esd0JBQXdCQyxFQUFFO0lBQy9EMUIsbUNBQW1DMEI7QUFDckM7QUFDQSxJQUFJQyxjQUFjLFNBQVNBLFlBQVlDLENBQUMsRUFBRUMsQ0FBQztJQUN6QyxPQUFPRCxNQUFNQztBQUNmO0FBQ0EsU0FBU0MscUJBQXFCQyxPQUFPO0lBQ25DLE9BQU8sU0FBU0MsY0FBY0MsUUFBUSxFQUFFQyxVQUFVO1FBQ2hELElBQUlBLGVBQWUsS0FBSyxHQUFHO1lBQ3pCQSxhQUFhUDtRQUNmO1FBQ0EsSUFBSVEsSUFBeUIsRUFBYztZQUN6QyxJQUFJLENBQUNGLFVBQVU7Z0JBQ2IsTUFBTSxJQUFJVCxNQUFNO1lBQ2xCO1lBQ0EsSUFBSSxPQUFPUyxhQUFhLFlBQVk7Z0JBQ2xDLE1BQU0sSUFBSVQsTUFBTTtZQUNsQjtZQUNBLElBQUksT0FBT1UsZUFBZSxZQUFZO2dCQUNwQyxNQUFNLElBQUlWLE1BQU07WUFDbEI7UUFDRjtRQUNBLElBQUlZLFFBQVFoQyxpREFBVUEsQ0FBQzJCO1FBRXZCOzs7Ozs7OztJQVFBLEdBQ0EsSUFBSU0sZ0JBQWdCckMsaUNBQWlDb0MsTUFBTUUsU0FBUyxFQUFFRixNQUFNRyxRQUFRLEVBQUVILE1BQU1HLFFBQVEsRUFDcEcsK0JBQStCO1FBQy9CTixVQUFVQztRQUNWN0Isb0RBQWFBLENBQUNnQztRQUNkLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLElBQUlMLGdCQUFnQkYscUJB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QUlDLFdBQVduYyw2Q0FBTUE7SUFDckIsSUFBSW9jLFlBQVlwYyw2Q0FBTUE7SUFDdEIsSUFBSTRCLFFBQVFtSSxXQUFXO1FBQ3JCLElBQUlzUyxnQkFBZ0JGLFNBQVMzYixPQUFPLElBQUksT0FBTzJiLFNBQVMzYixPQUFPLENBQUN1QixRQUFRLEtBQUsyRTtRQUM3RSxJQUFJN0MsU0FBU3FZLGlCQUFpQixPQUFPQSxjQUFjRyxlQUFlRCxVQUFVNWIsT0FBTyxJQUFJa0c7UUFDdkYsSUFBSTRWLFNBQVNuYyxZQUFZNmIsYUFBYUssZ0JBQWdCeFk7UUFDdER1WSxVQUFVNWIsT0FBTyxHQUFHcUQ7UUFDcEJzWSxTQUFTM2IsT0FBTyxHQUFHOGI7UUFDbkIsT0FBT0E7SUFDVCxHQUFHTDtJQUNILElBQUl2WixZQUFZNUMsK0NBQVFBLENBQUM7UUFDckIsT0FBTzhCLE1BQU1HLFFBQVE7SUFDdkIsSUFDQThFLGVBQWVuRSxTQUFTLENBQUMsRUFBRSxFQUMzQjZaLGtCQUFrQjdaLFNBQVMsQ0FBQyxFQUFFO0lBQ2hDM0MsZ0RBQVNBLENBQUM7UUFDUndjLGdCQUFnQjNhLE1BQU1HLFFBQVE7UUFDOUJILE1BQU1FLFNBQVMsQ0FBQztZQUNkLElBQUlzTixZQUFZeE4sTUFBTUcsUUFBUTtZQUM5QixJQUFJOEUsaUJBQWlCdUksV0FBVztnQkFDOUJtTixnQkFBZ0JuTjtZQUNsQjtRQUNGO0lBQ0YsR0FBRztRQUFDeE47S0FBTTtJQUNWLE9BQU87UUFBQ2lGO1FBQWNqRixNQUFNTyxVQUFVO1FBQUlQO0tBQU07QUFDbEQ7QUFFQSwwRUFBMEU7QUFDMUVYLHdCQUF3QnhCLHdHQUFrQ0E7QUFFcVYsQ0FDL1ksaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktYXBwLy4vbm9kZV9tb2R1bGVzL2Vhc3ktcGVhc3kvZGlzdC9pbmRleC5qcz82MmJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yJDEgfSBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3InO1xuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZURlYnVnVmFsdWUsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMic7XG5pbXBvcnQgeyBjb21wb3NlLCBjcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZSQxLCBhcHBseU1pZGRsZXdhcmUgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgcmVkdXhUaHVuayBmcm9tICdyZWR1eC10aHVuayc7XG5pbXBvcnQgeyBpc0RyYWZ0LCBjdXJyZW50LCBJbW1lciwgb3JpZ2luYWwsIHNldEF1dG9GcmVlemUsIHByb2R1Y2UgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgZXF1YWwgZnJvbSAnZmFzdC1kZWVwLWVxdWFsL2VzNic7XG5cbnZhciBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG5cbnZhciB1c2VOb3RJbml0aWFsaXplZCA9IGZ1bmN0aW9uIHVzZU5vdEluaXRpYWxpemVkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3VTRVMgbm90IGluaXRpYWxpemVkIScpO1xufTtcbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IHVzZU5vdEluaXRpYWxpemVkO1xudmFyIGluaXRpYWxpemVVc2VTdG9yZVN0YXRlID0gZnVuY3Rpb24gaW5pdGlhbGl6ZVVzZVN0b3JlU3RhdGUoZm4pIHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmbjtcbn07XG52YXIgcmVmRXF1YWxpdHkgPSBmdW5jdGlvbiByZWZFcXVhbGl0eShhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlU3RhdGVIb29rKENvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZVN0b3JlU3RhdGUobWFwU3RhdGUsIGVxdWFsaXR5Rm4pIHtcbiAgICBpZiAoZXF1YWxpdHlGbiA9PT0gdm9pZCAwKSB7XG4gICAgICBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIW1hcFN0YXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYSBzZWxlY3RvciB0byB1c2VTdG9yZVN0YXRlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBtYXBTdGF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYSBzZWxlY3RvciB0byB1c2VTdG9yZVN0YXRlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTdG9yZVN0YXRlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3RvcmUgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuXG4gICAgLypcclxuICAgIGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yPFNuYXBzaG90LCBTZWxlY3Rpb24+KFxyXG4gICAgICAgIHN1YnNjcmliZTogKG9uU3RvcmVDaGFuZ2U6ICgpID0+IHZvaWQpID0+ICgpID0+IHZvaWQsXHJcbiAgICAgICAgZ2V0U25hcHNob3Q6ICgpID0+IFNuYXBzaG90LFxyXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90OiB1bmRlZmluZWQgfCBudWxsIHwgKCgpID0+IFNuYXBzaG90KSxcclxuICAgICAgICBzZWxlY3RvcjogKHNuYXBzaG90OiBTbmFwc2hvdCkgPT4gU2VsZWN0aW9uLFxyXG4gICAgICAgIGlzRXF1YWw/OiAoYTogU2VsZWN0aW9uLCBiOiBTZWxlY3Rpb24pID0+IGJvb2xlYW4sXHJcbiAgICApOiBTZWxlY3Rpb247XHJcbiAgICAqL1xuICAgIHZhciBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3RvcmUuc3Vic2NyaWJlLCBzdG9yZS5nZXRTdGF0ZSwgc3RvcmUuZ2V0U3RhdGUsXG4gICAgLy8gZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTdGF0ZVxuICAgIG1hcFN0YXRlLCBlcXVhbGl0eUZuKTtcbiAgICB1c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlO1xuICB9O1xufVxudmFyIHVzZVN0b3JlU3RhdGUgPSBjcmVhdGVTdG9yZVN0YXRlSG9vayhTdG9yZUNvbnRleHQpO1xuZnVuY3Rpb24gY3JlYXRlU3RvcmVBY3Rpb25zSG9vayhDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VTdG9yZUFjdGlvbnMobWFwQWN0aW9ucykge1xuICAgIHZhciBzdG9yZSA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgcmV0dXJuIG1hcEFjdGlvbnMoc3RvcmUuZ2V0QWN0aW9ucygpKTtcbiAgfTtcbn1cbnZhciB1c2VTdG9yZUFjdGlvbnMgPSBjcmVhdGVTdG9yZUFjdGlvbnNIb29rKFN0b3JlQ29udGV4dCk7XG5mdW5jdGlvbiBjcmVhdGVTdG9yZURpc3BhdGNoSG9vayhDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VTdG9yZURpc3BhdGNoKCkge1xuICAgIHZhciBzdG9yZSA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoO1xuICB9O1xufVxudmFyIHVzZVN0b3JlRGlzcGF0Y2ggPSBjcmVhdGVTdG9yZURpc3BhdGNoSG9vayhTdG9yZUNvbnRleHQpO1xuZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdG9yZVJlaHlkcmF0ZWRIb29rKENvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZVN0b3JlUmVoeWRyYXRlZCgpIHtcbiAgICB2YXIgc3RvcmUgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICAgIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICByZWh5ZHJhdGVkID0gX3VzZVN0YXRlWzBdLFxuICAgICAgc2V0UmVoeWRyYXRlZCA9IF91c2VTdGF0ZVsxXTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgc3RvcmUucGVyc2lzdC5yZXNvbHZlUmVoeWRyYXRpb24oKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNldFJlaHlkcmF0ZWQodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHJlaHlkcmF0ZWQ7XG4gIH07XG59XG52YXIgdXNlU3RvcmVSZWh5ZHJhdGVkID0gY3JlYXRlU3RvcmVSZWh5ZHJhdGVkSG9vayhTdG9yZUNvbnRleHQpO1xuZnVuY3Rpb24gY3JlYXRlVHlwZWRIb29rcygpIHtcbiAgcmV0dXJuIHtcbiAgICB1c2VTdG9yZUFjdGlvbnM6IHVzZVN0b3JlQWN0aW9ucyxcbiAgICB1c2VTdG9yZURpc3BhdGNoOiB1c2VTdG9yZURpc3BhdGNoLFxuICAgIHVzZVN0b3JlU3RhdGU6IHVzZVN0b3JlU3RhdGUsXG4gICAgdXNlU3RvcmVSZWh5ZHJhdGVkOiB1c2VTdG9yZVJlaHlkcmF0ZWQsXG4gICAgdXNlU3RvcmU6IHVzZVN0b3JlXG4gIH07XG59XG5cbnZhciBhY3Rpb25TeW1ib2wgPSAnJF9hJztcbnZhciBhY3Rpb25PblN5bWJvbCA9ICckX2FPJztcbnZhciBjb21wdXRlZFN5bWJvbCA9ICckX2MnO1xudmFyIGVmZmVjdE9uU3ltYm9sID0gJyRfZSc7XG52YXIgcGVyc2lzdFN5bWJvbCA9ICckX3AnO1xudmFyIHJlZHVjZXJTeW1ib2wgPSAnJF9yJztcbnZhciB0aHVua09uU3ltYm9sID0gJyRfdE8nO1xudmFyIHRodW5rU3ltYm9sID0gJyRfdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKHN0YXRlKSB7XG4gIGlmIChpc0RyYWZ0KHN0YXRlKSkge1xuICAgIHJldHVybiBjdXJyZW50KHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59O1xudmFyIGFjdGlvbk9uID0gZnVuY3Rpb24gYWN0aW9uT24odGFyZ2V0UmVzb2x2ZXIsIGZuLCBjb25maWcpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiBfcmVmID0ge30sIF9yZWZbYWN0aW9uT25TeW1ib2xdID0gdHJ1ZSwgX3JlZi5mbiA9IGZuLCBfcmVmLnRhcmdldFJlc29sdmVyID0gdGFyZ2V0UmVzb2x2ZXIsIF9yZWYuY29uZmlnID0gY29uZmlnLCBfcmVmO1xufTtcbnZhciBhY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24oZm4sIGNvbmZpZykge1xuICB2YXIgX3JlZjI7XG4gIHJldHVybiBfcmVmMiA9IHt9LCBfcmVmMlthY3Rpb25TeW1ib2xdID0gdHJ1ZSwgX3JlZjIuZm4gPSBmbiwgX3JlZjIuY29uZmlnID0gY29uZmlnLCBfcmVmMjtcbn07XG52YXIgZGVmYXVsdFN0YXRlUmVzb2x2ZXJzID0gW2Z1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGU7XG59XTtcbnZhciBjb21wdXRlZCA9IGZ1bmN0aW9uIGNvbXB1dGVkKGZuT3JTdGF0ZVJlc29sdmVycywgZm4pIHtcbiAgdmFyIF9yZWY0O1xuICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIF9yZWYzO1xuICAgIHJldHVybiBfcmVmMyA9IHt9LCBfcmVmM1tjb21wdXRlZFN5bWJvbF0gPSB0cnVlLCBfcmVmMy5mbiA9IGZuLCBfcmVmMy5zdGF0ZVJlc29sdmVycyA9IGZuT3JTdGF0ZVJlc29sdmVycywgX3JlZjM7XG4gIH1cbiAgcmV0dXJuIF9yZWY0ID0ge30sIF9yZWY0W2NvbXB1dGVkU3ltYm9sXSA9IHRydWUsIF9yZWY0LmZuID0gZm5PclN0YXRlUmVzb2x2ZXJzLCBfcmVmNC5zdGF0ZVJlc29sdmVycyA9IGRlZmF1bHRTdGF0ZVJlc29sdmVycywgX3JlZjQ7XG59O1xuZnVuY3Rpb24gZWZmZWN0T24oZGVwZW5kZW5jeVJlc29sdmVycywgZm4pIHtcbiAgdmFyIF9yZWY1O1xuICByZXR1cm4gX3JlZjUgPSB7fSwgX3JlZjVbZWZmZWN0T25TeW1ib2xdID0gdHJ1ZSwgX3JlZjUuZGVwZW5kZW5jeVJlc29sdmVycyA9IGRlcGVuZGVuY3lSZXNvbHZlcnMsIF9yZWY1LmZuID0gZm4sIF9yZWY1O1xufVxuZnVuY3Rpb24gZ2VuZXJpYyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG52YXIgcGVyc2lzdCA9IGZ1bmN0aW9uIHBlcnNpc3QobW9kZWwsIGNvbmZpZykge1xuICB2YXIgX29iamVjdFNwcmVhZDI7XG4gIHJldHVybiAoXG4gICAgLy8gaWYgd2UgYXJlIG5vdCBydW5uaW5nIGluIGEgYnJvd3NlciBjb250ZXh0IHRoaXMgYmVjb21lcyBhIG5vLW9wXG4gICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBtb2RlbCA6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbW9kZWwpLCB7fSwgKF9vYmplY3RTcHJlYWQyID0ge30sIF9vYmplY3RTcHJlYWQyW3BlcnNpc3RTeW1ib2xdID0gY29uZmlnLCBfb2JqZWN0U3ByZWFkMikpXG4gICk7XG59O1xudmFyIHRodW5rT24gPSBmdW5jdGlvbiB0aHVua09uKHRhcmdldFJlc29sdmVyLCBmbikge1xuICB2YXIgX3JlZjY7XG4gIHJldHVybiBfcmVmNiA9IHt9LCBfcmVmNlt0aHVua09uU3ltYm9sXSA9IHRydWUsIF9yZWY2LmZuID0gZm4sIF9yZWY2LnRhcmdldFJlc29sdmVyID0gdGFyZ2V0UmVzb2x2ZXIsIF9yZWY2O1xufTtcbnZhciB0aHVuayA9IGZ1bmN0aW9uIHRodW5rKGZuKSB7XG4gIHZhciBfcmVmNztcbiAgcmV0dXJuIF9yZWY3ID0ge30sIF9yZWY3W3RodW5rU3ltYm9sXSA9IHRydWUsIF9yZWY3LmZuID0gZm4sIF9yZWY3O1xufTtcbnZhciByZWR1Y2VyID0gZnVuY3Rpb24gcmVkdWNlcihmbiwgY29uZmlnKSB7XG4gIHZhciBfcmVmODtcbiAgcmV0dXJuIF9yZWY4ID0ge30sIF9yZWY4W3JlZHVjZXJTeW1ib2xdID0gdHJ1ZSwgX3JlZjguZm4gPSBmbiwgX3JlZjguY29uZmlnID0gY29uZmlnLCBfcmVmODtcbn07XG5cbi8qKlxyXG4gKiBXZSBjcmVhdGUgb3VyIG93biBpbW1lciBpbnN0YW5jZSB0byBhdm9pZCBwb3RlbnRpYWwgaXNzdWVzIHdpdGggYXV0b0ZyZWV6ZVxyXG4gKiBiZWNvbWluZyBkZWZhdWx0IGVuYWJsZWQgZXZlcnl3aGVyZS4gV2Ugd2FudCB0byBkaXNhYmxlIGF1dG9mcmVlemUgYXMgaXRcclxuICogZG9lcyBub3Qgc3VpdCB0aGUgZGVzaWduIG9mIEVhc3kgUGVhc3kuXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW1lcmpzL2ltbWVyL2lzc3Vlcy82ODEjaXNzdWVjb21tZW50LTcwNTU4MTExMVxyXG4gKi9cbnZhciBlYXN5UGVhc3lJbW1lcjtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gb2JqO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IHByb3RvO1xufVxuZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZUNsb25lKGN1cnJlbnQpIHtcbiAgICB2YXIgbmV4dCA9IE9iamVjdC5rZXlzKGN1cnJlbnQpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN1cnJlbnQsIGtleSkuZ2V0ID09IG51bGwpIHtcbiAgICAgICAgYWNjW2tleV0gPSBjdXJyZW50W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBPYmplY3Qua2V5cyhuZXh0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KG5leHRba2V5XSkpIHtcbiAgICAgICAgbmV4dFtrZXldID0gcmVjdXJzaXZlQ2xvbmUobmV4dFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICByZXR1cm4gcmVjdXJzaXZlQ2xvbmUoc291cmNlKTtcbn1cbmZ1bmN0aW9uIGlzUHJvbWlzZSh4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBnZXQocGF0aCwgdGFyZ2V0KSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdChhY2MpID8gYWNjW2N1cl0gOiB1bmRlZmluZWQ7XG4gIH0sIHRhcmdldCk7XG59XG5mdW5jdGlvbiBuZXdpZnkoY3VycmVudFBhdGgsIGN1cnJlbnRTdGF0ZSwgZmluYWxWYWx1ZSkge1xuICBpZiAoY3VycmVudFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZpbmFsVmFsdWU7XG4gIH1cbiAgdmFyIG5ld1N0YXRlID0gX29iamVjdFNwcmVhZCh7fSwgY3VycmVudFN0YXRlKTtcbiAgdmFyIGtleSA9IGN1cnJlbnRQYXRoWzBdO1xuICBpZiAoY3VycmVudFBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgbmV3U3RhdGVba2V5XSA9IGZpbmFsVmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgbmV3U3RhdGVba2V5XSA9IG5ld2lmeShjdXJyZW50UGF0aC5zbGljZSgxKSwgbmV3U3RhdGVba2V5XSwgZmluYWxWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuZnVuY3Rpb24gc2V0KHBhdGgsIHRhcmdldCwgdmFsdWUpIHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1ciwgaWR4KSB7XG4gICAgaWYgKGlkeCArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICBhY2NbY3VyXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2NbY3VyXSA9IGFjY1tjdXJdIHx8IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYWNjW2N1cl07XG4gIH0sIHRhcmdldCk7XG59XG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVQcm9kdWNlKGRpc2FibGVJbW1lcikge1xuICBpZiAoZGlzYWJsZUltbWVyID09PSB2b2lkIDApIHtcbiAgICBkaXNhYmxlSW1tZXIgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gc2ltcGxlUHJvZHVjZShwYXRoLCBzdGF0ZSwgZm4sIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgJiYgJ2ltbWVyJyBpbiBjb25maWcgPyAoY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuaW1tZXIpID09PSBmYWxzZSA6IGRpc2FibGVJbW1lcikge1xuICAgICAgdmFyIF9jdXJyZW50ID0gZ2V0KHBhdGgsIHN0YXRlKTtcbiAgICAgIHZhciBuZXh0ID0gZm4oX2N1cnJlbnQpO1xuICAgICAgaWYgKF9jdXJyZW50ICE9PSBuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXdpZnkocGF0aCwgc3RhdGUsIG5leHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBpZiAoIWVhc3lQZWFzeUltbWVyKSB7XG4gICAgICBlYXN5UGVhc3lJbW1lciA9IG5ldyBJbW1lcih7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgd2UgZGlzYWJsZSBwcm94aWVzIGlmIHRoZXkgYXJlbid0IGF2YWlsYWJsZVxuICAgICAgICAvLyBvbiB0aGUgZW52aXJvbm1lbnQuIFVzZXJzIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhleSB1c2UgdGhlIGVuYWJsZUVTNVxuICAgICAgICAvLyBmZWF0dXJlIG9mIGltbWVyLlxuICAgICAgICB1c2VQcm94aWVzOiB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBQcm94eS5yZXZvY2FibGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgLy8gQXV0b2ZyZWV6aW5nIGJyZWFrcyBlYXN5LXBlYXN5LCB3ZSBuZWVkIGEgbWl4ZWQgdmVyc2lvbiBvZiBpbW11dGFiaWxpdHlcbiAgICAgICAgLy8gYW5kIG11dGFiaWxpdHkgaW4gb3JkZXIgdG8gYXBwbHkgdXBkYXRlcyB0byBvdXIgY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICAgICBhdXRvRnJlZXplOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIF9kcmFmdCA9IGVhc3lQZWFzeUltbWVyLmNyZWF0ZURyYWZ0KHN0YXRlKTtcbiAgICAgIHZhciBfcmVzdWx0ID0gZm4oX2RyYWZ0KTtcbiAgICAgIGlmIChfcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBpc0RyYWZ0KF9yZXN1bHQpID8gZWFzeVBlYXN5SW1tZXIuZmluaXNoRHJhZnQoX3Jlc3VsdCkgOiBfcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVhc3lQZWFzeUltbWVyLmZpbmlzaERyYWZ0KF9kcmFmdCk7XG4gICAgfVxuICAgIHZhciBwYXJlbnRQYXRoID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIHZhciBkcmFmdCA9IGVhc3lQZWFzeUltbWVyLmNyZWF0ZURyYWZ0KHN0YXRlKTtcbiAgICB2YXIgcGFyZW50ID0gZ2V0KHBhcmVudFBhdGgsIHN0YXRlKTtcbiAgICB2YXIgY3VycmVudCA9IGdldChwYXRoLCBkcmFmdCk7XG4gICAgdmFyIHJlc3VsdCA9IGZuKGN1cnJlbnQpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHBhcmVudFtwYXRoW3BhdGgubGVuZ3RoIC0gMV1dID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZWFzeVBlYXN5SW1tZXIuZmluaXNoRHJhZnQoZHJhZnQpO1xuICB9O1xufVxudmFyIHBSZWR1Y2UgPSBmdW5jdGlvbiBwUmVkdWNlKGl0ZXJhYmxlLCByZWR1Y2VyLCBpbml0aWFsVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQodG90YWwpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKGVsZW1lbnQuZG9uZSkge1xuICAgICAgICByZXNvbHZlKHRvdGFsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgUHJvbWlzZS5hbGwoW3RvdGFsLCBlbGVtZW50LnZhbHVlXSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGx1c3BsdXNcbiAgICAgICAgICBuZXh0KHJlZHVjZXIodmFsdWVbMF0sIHZhbHVlWzFdLCBpbmRleCsrKSlcbiAgICAgICAgKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBuZXh0KGluaXRpYWxWYWx1ZSk7XG4gIH0pO1xufTtcbnZhciBwU2VyaWVzID0gZnVuY3Rpb24gcFNlcmllcyh0YXNrcykge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICByZXR1cm4gcFJlZHVjZSh0YXNrcywgZnVuY3Rpb24gKF8sIHRhc2spIHtcbiAgICByZXR1cm4gdGFzaygpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSk7XG59O1xuZnVuY3Rpb24gYXJlSW5wdXRzRXF1YWwobmV3SW5wdXRzLCBsYXN0SW5wdXRzKSB7XG4gIGlmIChuZXdJbnB1dHMubGVuZ3RoICE9PSBsYXN0SW5wdXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0lucHV0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChuZXdJbnB1dHNbaV0gIT09IGxhc3RJbnB1dHNbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1c2VNZW1vT25lKFxuLy8gZ2V0UmVzdWx0IGNoYW5nZXMgb24gZXZlcnkgY2FsbCxcbmdldFJlc3VsdCxcbi8vIHRoZSBpbnB1dHMgYXJyYXkgY2hhbmdlcyBvbiBldmVyeSBjYWxsXG5pbnB1dHMpIHtcbiAgLy8gdXNpbmcgdXNlU3RhdGUgdG8gZ2VuZXJhdGUgaW5pdGlhbCB2YWx1ZSBhcyBpdCBpcyBsYXp5XG4gIHZhciBpbml0aWFsID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dHM6IGlucHV0cyxcbiAgICAgIHJlc3VsdDogZ2V0UmVzdWx0KClcbiAgICB9O1xuICB9KVswXTtcbiAgdmFyIGNvbW1pdHRlZCA9IFJlYWN0LnVzZVJlZihpbml0aWFsKTtcblxuICAvLyBwZXJzaXN0IGFueSB1bmNvbW1pdHRlZCBjaGFuZ2VzIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIGNvbW1pdHRlZFxuXG4gIHZhciBpc0lucHV0TWF0Y2ggPSBCb29sZWFuKGlucHV0cyAmJiBjb21taXR0ZWQuY3VycmVudC5pbnB1dHMgJiYgYXJlSW5wdXRzRXF1YWwoaW5wdXRzLCBjb21taXR0ZWQuY3VycmVudC5pbnB1dHMpKTtcblxuICAvLyBjcmVhdGUgYSBuZXcgY2FjaGUgaWYgcmVxdWlyZWRcbiAgdmFyIGNhY2hlID0gaXNJbnB1dE1hdGNoID8gY29tbWl0dGVkLmN1cnJlbnQgOiB7XG4gICAgaW5wdXRzOiBpbnB1dHMsXG4gICAgcmVzdWx0OiBnZXRSZXN1bHQoKVxuICB9O1xuXG4gIC8vIGNvbW1pdCB0aGUgY2FjaGVcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBjb21taXR0ZWQuY3VycmVudCA9IGNhY2hlO1xuICB9LCBbY2FjaGVdKTtcbiAgcmV0dXJuIGNhY2hlLnJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihkaXNhYmxlSW1tZXIsIF9hUkQsIF9jUiwgX2NQKSB7XG4gIHZhciBzaW1wbGVQcm9kdWNlID0gY3JlYXRlU2ltcGxlUHJvZHVjZShkaXNhYmxlSW1tZXIpO1xuICB2YXIgcnVuQWN0aW9uUmVkdWNlckF0UGF0aCA9IGZ1bmN0aW9uIHJ1bkFjdGlvblJlZHVjZXJBdFBhdGgoc3RhdGUsIGFjdGlvbiwgYWN0aW9uUmVkdWNlciwgcGF0aCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHNpbXBsZVByb2R1Y2UocGF0aCwgc3RhdGUsIGZ1bmN0aW9uIChkcmFmdCkge1xuICAgICAgcmV0dXJuIGFjdGlvblJlZHVjZXIoZHJhZnQsIGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9LCBjb25maWcpO1xuICB9O1xuICB2YXIgcmVkdWNlckZvckFjdGlvbnMgPSBmdW5jdGlvbiByZWR1Y2VyRm9yQWN0aW9ucyhzdGF0ZSwgYWN0aW9uKSB7XG4gICAgdmFyIGFjdGlvblJlZHVjZXIgPSBfYVJEW2FjdGlvbi50eXBlXTtcbiAgICBpZiAoYWN0aW9uUmVkdWNlcikge1xuICAgICAgcmV0dXJuIHJ1bkFjdGlvblJlZHVjZXJBdFBhdGgoc3RhdGUsIGFjdGlvbiwgYWN0aW9uUmVkdWNlciwgYWN0aW9uUmVkdWNlci5kZWYubWV0YS5wYXJlbnQsIGFjdGlvblJlZHVjZXIuZGVmLmNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbiAgdmFyIHJlZHVjZXJGb3JDdXN0b21SZWR1Y2VycyA9IGZ1bmN0aW9uIHJlZHVjZXJGb3JDdXN0b21SZWR1Y2VycyhzdGF0ZSwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIF9jUi5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX3JlZikge1xuICAgICAgdmFyIHBhcmVudFBhdGggPSBfcmVmLnBhcmVudFBhdGgsXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICByZWR1Y2VyID0gX3JlZi5yZWR1Y2VyLFxuICAgICAgICBjb25maWcgPSBfcmVmLmNvbmZpZztcbiAgICAgIHJldHVybiBzaW1wbGVQcm9kdWNlKHBhcmVudFBhdGgsIGFjYywgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICAgIGRyYWZ0W2tleV0gPSByZWR1Y2VyKGlzRHJhZnQoZHJhZnRba2V5XSkgPyBvcmlnaW5hbChkcmFmdFtrZXldKSA6IGRyYWZ0W2tleV0sIGFjdGlvbik7XG4gICAgICAgIHJldHVybiBkcmFmdDtcbiAgICAgIH0sIGNvbmZpZyk7XG4gICAgfSwgc3RhdGUpO1xuICB9O1xuICB2YXIgcm9vdFJlZHVjZXIgPSBmdW5jdGlvbiByb290UmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgdmFyIHN0YXRlQWZ0ZXJBY3Rpb25zID0gcmVkdWNlckZvckFjdGlvbnMoc3RhdGUsIGFjdGlvbik7XG4gICAgdmFyIG5leHQgPSBfY1IubGVuZ3RoID4gMCA/IHJlZHVjZXJGb3JDdXN0b21SZWR1Y2VycyhzdGF0ZUFmdGVyQWN0aW9ucywgYWN0aW9uKSA6IHN0YXRlQWZ0ZXJBY3Rpb25zO1xuICAgIGlmIChzdGF0ZSAhPT0gbmV4dCkge1xuICAgICAgX2NQLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBwYXJlbnRQYXRoID0gX3JlZjIucGFyZW50UGF0aCxcbiAgICAgICAgICBiaW5kQ29tcHV0ZWRQcm9wZXJ0eSA9IF9yZWYyLmJpbmRDb21wdXRlZFByb3BlcnR5O1xuICAgICAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXQocGFyZW50UGF0aCwgbmV4dCk7XG4gICAgICAgIGlmIChwYXJlbnRTdGF0ZSAhPSBudWxsKSBiaW5kQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnRTdGF0ZSwgbmV4dCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG4gIHJldHVybiByb290UmVkdWNlcjtcbn1cblxudmFyIG1pZ3JhdGUgPSBmdW5jdGlvbiBtaWdyYXRlKGRhdGEsIG1pZ3JhdGlvbnMpIHtcbiAgdmFyIF9kYXRhJF9taWdyYXRpb25WZXJzaTtcbiAgc2V0QXV0b0ZyZWV6ZShmYWxzZSk7XG4gIHZhciB2ZXJzaW9uID0gKF9kYXRhJF9taWdyYXRpb25WZXJzaSA9IGRhdGEuX21pZ3JhdGlvblZlcnNpb24pICE9IG51bGwgPyBfZGF0YSRfbWlncmF0aW9uVmVyc2kgOiAwO1xuICB2YXIgdG9WZXJzaW9uID0gbWlncmF0aW9ucy5taWdyYXRpb25WZXJzaW9uO1xuICBpZiAodHlwZW9mIHZlcnNpb24gIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRvVmVyc2lvbiAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1pZ3JhdGlvbiB2ZXJzaW9uIGZvdW5kJyk7XG4gIH1cbiAgd2hpbGUgKHZlcnNpb24gPCB0b1ZlcnNpb24pIHtcbiAgICB2YXIgbmV4dFZlcnNpb24gPSB2ZXJzaW9uICsgMTtcbiAgICB2YXIgbWlncmF0b3IgPSBtaWdyYXRpb25zW25leHRWZXJzaW9uXTtcbiAgICBpZiAoIW1pZ3JhdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtaWdyYXRvciBmb3VuZCBmb3IgYG1pZ3JhdGlvblZlcnNpb25gIFwiICsgbmV4dFZlcnNpb24pO1xuICAgIH1cbiAgICBkYXRhID0gcHJvZHVjZShkYXRhLCBtaWdyYXRvcik7XG4gICAgZGF0YS5fbWlncmF0aW9uVmVyc2lvbiA9IG5leHRWZXJzaW9uO1xuICAgIHZlcnNpb24gPSBkYXRhLl9taWdyYXRpb25WZXJzaW9uO1xuICB9XG4gIHNldEF1dG9GcmVlemUodHJ1ZSk7XG4gIHJldHVybiBkYXRhO1xufTtcblxudmFyIG5vb3BTdG9yYWdlID0ge1xuICBnZXRJdGVtOiBmdW5jdGlvbiBnZXRJdGVtKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG4gIHNldEl0ZW06IGZ1bmN0aW9uIHNldEl0ZW0oKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcbiAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gcmVtb3ZlSXRlbSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xudmFyIGdldEJyb3dlclN0b3JhZ2UgPSBmdW5jdGlvbiBnZXRCcm93ZXJTdG9yYWdlKHN0b3JhZ2VOYW1lKSB7XG4gIHZhciBzdG9yYWdlQ2FjaGU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzdG9yYWdlQ2FjaGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93W3N0b3JhZ2VOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzdG9yYWdlQ2FjaGUgPSB3aW5kb3dbc3RvcmFnZU5hbWVdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIC8vIHN3YWxsb3cgdGhlIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGlmICghc3RvcmFnZUNhY2hlKSB7XG4gICAgICAgIHN0b3JhZ2VDYWNoZSA9IG5vb3BTdG9yYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RvcmFnZUNhY2hlO1xuICB9O1xufTtcbnZhciBsb2NhbFN0b3JhZ2UgPSBnZXRCcm93ZXJTdG9yYWdlKCdsb2NhbFN0b3JhZ2UnKTtcbnZhciBzZXNzaW9uU3RvcmFnZSA9IGdldEJyb3dlclN0b3JhZ2UoJ3Nlc3Npb25TdG9yYWdlJyk7XG5mdW5jdGlvbiBjcmVhdGVTdG9yYWdlV3JhcHBlcihzdG9yYWdlLCB0cmFuc2Zvcm1lcnMsIG1pZ3JhdGlvbnMpIHtcbiAgaWYgKHRyYW5zZm9ybWVycyA9PT0gdm9pZCAwKSB7XG4gICAgdHJhbnNmb3JtZXJzID0gW107XG4gIH1cbiAgaWYgKG1pZ3JhdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG1pZ3JhdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAoc3RvcmFnZSA9PSBudWxsKSB7XG4gICAgc3RvcmFnZSA9IHNlc3Npb25TdG9yYWdlKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdG9yYWdlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChzdG9yYWdlID09PSAnbG9jYWxTdG9yYWdlJykge1xuICAgICAgc3RvcmFnZSA9IGxvY2FsU3RvcmFnZSgpO1xuICAgIH0gZWxzZSBpZiAoc3RvcmFnZSA9PT0gJ3Nlc3Npb25TdG9yYWdlJykge1xuICAgICAgc3RvcmFnZSA9IHNlc3Npb25TdG9yYWdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHN0b3JhZ2UgcHJvdmlkZXJcIik7XG4gICAgICB9XG4gICAgICBzdG9yYWdlID0gbm9vcFN0b3JhZ2U7XG4gICAgfVxuICB9XG4gIHZhciBvdXRUcmFuc2Zvcm1lcnMgPSBbXS5jb25jYXQodHJhbnNmb3JtZXJzKS5yZXZlcnNlKCk7XG4gIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZGF0YSkge1xuICAgIGlmICh0cmFuc2Zvcm1lcnMubGVuZ3RoID4gMCAmJiBkYXRhICE9IG51bGwgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdHJhbnNmb3JtZXJzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICAgICAgICByZXR1cm4gY3VyLmluKGFjYywga2V5LCBkYXRhKTtcbiAgICAgICAgfSwgZGF0YVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmFnZSA9PT0gbG9jYWxTdG9yYWdlKCkgfHwgc3RvcmFnZSA9PT0gc2Vzc2lvblN0b3JhZ2UoKSA/IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSA6IGRhdGE7XG4gIH07XG4gIHZhciBkZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICB2YXIgc3RvcmFnZURhdGEgPSBzdG9yYWdlID09PSBsb2NhbFN0b3JhZ2UoKSB8fCBzdG9yYWdlID09PSBzZXNzaW9uU3RvcmFnZSgpID8gSlNPTi5wYXJzZShkYXRhKS5kYXRhIDogZGF0YTtcbiAgICB2YXIgaGFzTWlncmF0aW9ucyA9IE9iamVjdC5rZXlzKG1pZ3JhdGlvbnMpLmxlbmd0aCA+IDA7XG4gICAgdmFyIHJlc3VsdCA9IGhhc01pZ3JhdGlvbnMgPyBtaWdyYXRlKHN0b3JhZ2VEYXRhLCBtaWdyYXRpb25zKSA6IHN0b3JhZ2VEYXRhO1xuICAgIGlmIChvdXRUcmFuc2Zvcm1lcnMubGVuZ3RoID4gMCAmJiByZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBvdXRUcmFuc2Zvcm1lcnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cikge1xuICAgICAgICAgIHJldHVybiBjdXIub3V0KGFjYywga2V5LCByZXN1bHQpO1xuICAgICAgICB9LCByZXN1bHRba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgdmFyIGlzQXN5bmMgPSBpc1Byb21pc2Uoc3RvcmFnZS5nZXRJdGVtKCdfJykpO1xuICByZXR1cm4ge1xuICAgIGdldEl0ZW06IGZ1bmN0aW9uIGdldEl0ZW0oa2V5KSB7XG4gICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICByZXR1cm4gc3RvcmFnZS5nZXRJdGVtKGtleSkudGhlbihmdW5jdGlvbiAod3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVkICE9IG51bGwgPyBkZXNlcmlhbGl6ZSh3cmFwcGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgd3JhcHBlZCA9IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgcmV0dXJuIHdyYXBwZWQgIT0gbnVsbCA/IGRlc2VyaWFsaXplKHdyYXBwZWQpIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgc2V0SXRlbTogZnVuY3Rpb24gc2V0SXRlbShrZXksIGRhdGEpIHtcbiAgICAgIHJldHVybiBzdG9yYWdlLnNldEl0ZW0oa2V5LCBzZXJpYWxpemUoZGF0YSkpO1xuICAgIH0sXG4gICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgIHJldHVybiBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBleHRyYWN0UGVyc2lzdENvbmZpZyhwYXRoLCBwZXJzaXN0ZGVmKSB7XG4gIGlmIChwZXJzaXN0ZGVmID09PSB2b2lkIDApIHtcbiAgICBwZXJzaXN0ZGVmID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIGNvbmZpZzoge1xuICAgICAgYWxsb3c6IHBlcnNpc3RkZWYuYWxsb3cgfHwgW10sXG4gICAgICBkZW55OiBwZXJzaXN0ZGVmLmRlbnkgfHwgW10sXG4gICAgICBtZXJnZVN0cmF0ZWd5OiBwZXJzaXN0ZGVmLm1lcmdlU3RyYXRlZ3kgfHwgJ21lcmdlRGVlcCcsXG4gICAgICBzdG9yYWdlOiBjcmVhdGVTdG9yYWdlV3JhcHBlcihwZXJzaXN0ZGVmLnN0b3JhZ2UsIHBlcnNpc3RkZWYudHJhbnNmb3JtZXJzLCBwZXJzaXN0ZGVmLm1pZ3JhdGlvbnMpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBlcnNpc3RUYXJnZXRzKHRhcmdldCwgYWxsb3csIGRlbnkpIHtcbiAgdmFyIHRhcmdldHMgPSBPYmplY3Qua2V5cyh0YXJnZXQpO1xuICBpZiAoYWxsb3cubGVuZ3RoID4gMCkge1xuICAgIHRhcmdldHMgPSB0YXJnZXRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICAgIGlmIChhbGxvdy5maW5kSW5kZXgoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IGN1cjtcbiAgICAgIH0pICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KGFjYywgW2N1cl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKGRlbnkubGVuZ3RoID4gMCkge1xuICAgIHRhcmdldHMgPSB0YXJnZXRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICAgIGlmIChkZW55LmZpbmRJbmRleChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCA9PT0gY3VyO1xuICAgICAgfSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICByZXR1cm4gW10uY29uY2F0KGFjYywgW2N1cl0pO1xuICAgIH0sIFtdKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0cztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBlcnNpc3RlbmNlQ2xlYXJlcihwZXJzaXN0S2V5LCBfcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfci5faS5fcGVyc2lzdGVuY2VDb25maWcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBwU2VyaWVzKF9yLl9pLl9wZXJzaXN0ZW5jZUNvbmZpZy5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgICBjb25maWcgPSBfcmVmLmNvbmZpZztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29uZmlnLnN0b3JhZ2UucmVtb3ZlSXRlbShwZXJzaXN0S2V5KHBhdGgpKSk7XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBlcnNpc3RvcihwZXJzaXN0S2V5LCBfcikge1xuICB2YXIgcGVyc2lzdFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdmFyIGlzUGVyc2lzdGluZyA9IGZhbHNlO1xuICB2YXIgbmV4dFBlcnNpc3RPcGVyYXRpb247XG4gIHZhciB0aW1pbmdNZXRob2QgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBmbigpO1xuICB9IDogd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgIT0gbnVsbCA/XG4gIC8vIFdlIG5lZWQgdG8gd3JhcCByZXF1ZXN0SWRsZUNhbGxiYWNrLCBiZWNhdXNlIGl0IGRvZXNuJ3Qgd29yayB3aXRob3V0XG4gIC8vIGEgc2Vjb25kIHBhcmFtZXRlciBvbiBpT1Mgd2l0aCBSZWFjdE5hdGl2ZVxuICBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soZm4sIHtcbiAgICAgIHRpbWVvdXQ6IDBcbiAgICB9KTtcbiAgfSA6IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIHZhciBwZXJzaXN0ID0gZnVuY3Rpb24gcGVyc2lzdChuZXh0U3RhdGUpIHtcbiAgICBpZiAoX3IuX2kuX3BlcnNpc3RlbmNlQ29uZmlnLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb3BlcmF0aW9uID0gZnVuY3Rpb24gb3BlcmF0aW9uKCkge1xuICAgICAgaXNQZXJzaXN0aW5nID0gdHJ1ZTtcbiAgICAgIHBlcnNpc3RQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdGltaW5nTWV0aG9kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwU2VyaWVzKF9yLl9pLl9wZXJzaXN0ZW5jZUNvbmZpZy5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IF9yZWYyLnBhdGgsXG4gICAgICAgICAgICAgIGNvbmZpZyA9IF9yZWYyLmNvbmZpZztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBzdG9yYWdlID0gY29uZmlnLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgYWxsb3cgPSBjb25maWcuYWxsb3csXG4gICAgICAgICAgICAgICAgZGVueSA9IGNvbmZpZy5kZW55O1xuICAgICAgICAgICAgICB2YXIgcGVyc2lzdFJvb3RTdGF0ZSA9IGNsb25lKGdldChwYXRoLCBuZXh0U3RhdGUpKTtcbiAgICAgICAgICAgICAgdmFyIHBlcnNpc3RUYXJnZXRzID0gcmVzb2x2ZVBlcnNpc3RUYXJnZXRzKHBlcnNpc3RSb290U3RhdGUsIGFsbG93LCBkZW55KTtcbiAgICAgICAgICAgICAgdmFyIHN0YXRlVG9QZXJzaXN0ID0ge307XG4gICAgICAgICAgICAgIHBlcnNpc3RUYXJnZXRzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFBhdGggPSBbXS5jb25jYXQocGF0aCwgW2tleV0pO1xuICAgICAgICAgICAgICAgIHZhciByYXdWYWx1ZSA9IGdldCh0YXJnZXRQYXRoLCBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlzUGxhaW5PYmplY3QocmF3VmFsdWUpID8gY2xvbmUocmF3VmFsdWUpIDogcmF3VmFsdWU7XG4gICAgICAgICAgICAgICAgc3RhdGVUb1BlcnNpc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdG9yYWdlLnNldEl0ZW0ocGVyc2lzdEtleShwYXRoKSwgc3RhdGVUb1BlcnNpc3QpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkpLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXNQZXJzaXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dFBlcnNpc3RPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSBuZXh0UGVyc2lzdE9wZXJhdGlvbjtcbiAgICAgICAgICAgICAgbmV4dFBlcnNpc3RPcGVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoaXNQZXJzaXN0aW5nKSB7XG4gICAgICBuZXh0UGVyc2lzdE9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHBlcnNpc3Q6IHBlcnNpc3QsXG4gICAgY2xlYXI6IGNyZWF0ZVBlcnNpc3RlbmNlQ2xlYXJlcihwZXJzaXN0S2V5LCBfciksXG4gICAgZmx1c2g6IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgaWYgKG5leHRQZXJzaXN0T3BlcmF0aW9uKSB7XG4gICAgICAgIG5leHRQZXJzaXN0T3BlcmF0aW9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGVyc2lzdFByb21pc2U7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGVyc2lzdE1pZGRsZXdhcmUocGVyc2lzdG9yLCBfcikge1xuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIGdldFN0YXRlID0gX3JlZjMuZ2V0U3RhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgc3RhdGUgPSBuZXh0KGFjdGlvbik7XG4gICAgICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uLnR5cGUgIT09ICdAYWN0aW9uLmVQUlMnICYmIF9yLl9pLl9wZXJzaXN0ZW5jZUNvbmZpZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGVyc2lzdG9yLnBlcnNpc3QoZ2V0U3RhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gcmVoeWRyYXRlU3RhdGVGcm9tUGVyc2lzdElmTmVlZGVkKHBlcnNpc3RLZXksIHJlcGxhY2VTdGF0ZSwgX3IsIHJvb3QpIHtcbiAgaWYgKF9yLl9pLl9wZXJzaXN0ZW5jZUNvbmZpZy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgdmFyIHN0YXRlID0gY2xvbmUoX3IuX2kuX2RTKTtcbiAgdmFyIHJlaHlkcmF0aW5nID0gZmFsc2U7XG4gIHJldHVybiBwU2VyaWVzKF9yLl9pLl9wZXJzaXN0ZW5jZUNvbmZpZy5tYXAoZnVuY3Rpb24gKHBlcnNpc3RJbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aCA9IHBlcnNpc3RJbnN0YW5jZS5wYXRoLFxuICAgICAgICBjb25maWcgPSBwZXJzaXN0SW5zdGFuY2UuY29uZmlnO1xuICAgICAgdmFyIG1lcmdlU3RyYXRlZ3kgPSBjb25maWcubWVyZ2VTdHJhdGVneSxcbiAgICAgICAgc3RvcmFnZSA9IGNvbmZpZy5zdG9yYWdlO1xuICAgICAgaWYgKHJvb3QgJiYgKHBhdGgubGVuZ3RoIDwgMSB8fCBwYXRoWzBdICE9PSByb290KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzRGF0YU1vZGVsQ2hhbmdlZCA9IGZ1bmN0aW9uIGhhc0RhdGFNb2RlbENoYW5nZWQoZGF0YU1vZGVsLCByZWh5ZHJhdGluZ01vZGVsRGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YU1vZGVsICE9IG51bGwgJiYgcmVoeWRyYXRpbmdNb2RlbERhdGEgIT0gbnVsbCAmJiAodHlwZW9mIGRhdGFNb2RlbCAhPT0gdHlwZW9mIHJlaHlkcmF0aW5nTW9kZWxEYXRhIHx8IEFycmF5LmlzQXJyYXkoZGF0YU1vZGVsKSAmJiAhQXJyYXkuaXNBcnJheShyZWh5ZHJhdGluZ01vZGVsRGF0YSkpO1xuICAgICAgfTtcbiAgICAgIHZhciBhcHBseVJlaHlkcmF0aW9uU3RyYXRlZ3kgPSBmdW5jdGlvbiBhcHBseVJlaHlkcmF0aW9uU3RyYXRlZ3kocGVyc2lzdGVkU3RhdGUpIHtcbiAgICAgICAgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdvdmVyd3JpdGUnKSB7XG4gICAgICAgICAgc2V0KHBhdGgsIHN0YXRlLCBwZXJzaXN0ZWRTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVyZ2VTdHJhdGVneSA9PT0gJ21lcmdlU2hhbGxvdycpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0U3RhdGUgPSBnZXQocGF0aCwgc3RhdGUpO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHBlcnNpc3RlZFN0YXRlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChoYXNEYXRhTW9kZWxDaGFuZ2VkKHRhcmdldFN0YXRlW2tleV0sIHBlcnNpc3RlZFN0YXRlW2tleV0pKSA7IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRTdGF0ZVtrZXldID0gcGVyc2lzdGVkU3RhdGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXJnZVN0cmF0ZWd5ID09PSAnbWVyZ2VEZWVwJykge1xuICAgICAgICAgIHZhciBfdGFyZ2V0U3RhdGUgPSBnZXQocGF0aCwgc3RhdGUpO1xuICAgICAgICAgIHZhciBzZXRBdCA9IGZ1bmN0aW9uIHNldEF0KGN1cnJlbnRUYXJnZXRTdGF0ZSwgY3VycmVudFBlcnNpc3RlZFN0YXRlKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjdXJyZW50UGVyc2lzdGVkU3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICBpZiAoaGFzRGF0YU1vZGVsQ2hhbmdlZChjdXJyZW50VGFyZ2V0U3RhdGVba2V5XSwgY3VycmVudFBlcnNpc3RlZFN0YXRlW2tleV0pKSA7IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoY3VycmVudFBlcnNpc3RlZFN0YXRlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldFN0YXRlW2tleV0gPSBjdXJyZW50VGFyZ2V0U3RhdGVba2V5XSB8fCB7fTtcbiAgICAgICAgICAgICAgICBzZXRBdChjdXJyZW50VGFyZ2V0U3RhdGVba2V5XSwgY3VycmVudFBlcnNpc3RlZFN0YXRlW2tleV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXRTdGF0ZVtrZXldID0gY3VycmVudFBlcnNpc3RlZFN0YXRlW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgc2V0QXQoX3RhcmdldFN0YXRlLCBwZXJzaXN0ZWRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcmVoeWRhdGUgPSBmdW5jdGlvbiByZWh5ZGF0ZShwZXJzaXN0ZWRTdGF0ZSkge1xuICAgICAgICBpZiAocGVyc2lzdGVkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIGFwcGx5UmVoeWRyYXRpb25TdHJhdGVneShwZXJzaXN0ZWRTdGF0ZSk7XG4gICAgICAgICAgcmVoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGdldEl0ZW1SZXN1bHQgPSBzdG9yYWdlLmdldEl0ZW0ocGVyc2lzdEtleShwYXRoKSk7XG4gICAgICBpZiAoaXNQcm9taXNlKGdldEl0ZW1SZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBnZXRJdGVtUmVzdWx0LnRoZW4ocmVoeWRhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWh5ZGF0ZShnZXRJdGVtUmVzdWx0KSk7XG4gICAgfTtcbiAgfSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZWh5ZHJhdGluZykge1xuICAgICAgcmVwbGFjZVN0YXRlKHN0YXRlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25DcmVhdG9yKGRlZiwgX3IpIHtcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihwYXlsb2FkKSB7XG4gICAgdmFyIGFjdGlvbiA9IHtcbiAgICAgIHR5cGU6IGRlZi5tZXRhLnR5cGUsXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgY29uZmlnOiBkZWYuY29uZmlnXG4gICAgfTtcbiAgICBpZiAoZGVmW2FjdGlvbk9uU3ltYm9sXSAmJiBkZWYubWV0YS5yZXNvbHZlZFRhcmdldHMpIHtcbiAgICAgIHBheWxvYWQucmVzb2x2ZWRUYXJnZXRzID0gW10uY29uY2F0KGRlZi5tZXRhLnJlc29sdmVkVGFyZ2V0cyk7XG4gICAgfVxuICAgIHJldHVybiBfci5kaXNwYXRjaChhY3Rpb24pO1xuICB9XG5cbiAgLy8gV2UgYmluZCB0aGUgdHlwZXMgdG8gdGhlIGNyZWF0b3IgZm9yIGVhc3kgcmVmZXJlbmNlIGJ5IGNvbnN1bWVyc1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSBkZWYubWV0YS50eXBlO1xuICByZXR1cm4gYWN0aW9uQ3JlYXRvcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGh1bmtIYW5kbGVyKGRlZiwgX3IsIGluamVjdGlvbnMsIF9hQykge1xuICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQsIGZhaWwpIHtcbiAgICB2YXIgaGVscGVycyA9IHtcbiAgICAgIGRpc3BhdGNoOiBfci5kaXNwYXRjaCxcbiAgICAgIGZhaWw6IGZhaWwsXG4gICAgICBnZXRTdGF0ZTogZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBnZXQoZGVmLm1ldGEucGFyZW50LCBfci5nZXRTdGF0ZSgpKTtcbiAgICAgIH0sXG4gICAgICBnZXRTdG9yZUFjdGlvbnM6IGZ1bmN0aW9uIGdldFN0b3JlQWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIF9hQztcbiAgICAgIH0sXG4gICAgICBnZXRTdG9yZVN0YXRlOiBfci5nZXRTdGF0ZSxcbiAgICAgIGluamVjdGlvbnM6IGluamVjdGlvbnMsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIGtleTogZGVmLm1ldGEuYWN0aW9uTmFtZSxcbiAgICAgICAgcGFyZW50OiBkZWYubWV0YS5wYXJlbnQsXG4gICAgICAgIHBhdGg6IGRlZi5tZXRhLnBhdGhcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChkZWZbdGh1bmtPblN5bWJvbF0gJiYgZGVmLm1ldGEucmVzb2x2ZWRUYXJnZXRzKSB7XG4gICAgICBwYXlsb2FkLnJlc29sdmVkVGFyZ2V0cyA9IFtdLmNvbmNhdChkZWYubWV0YS5yZXNvbHZlZFRhcmdldHMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmLmZuKGdldChkZWYubWV0YS5wYXJlbnQsIF9hQyksIHBheWxvYWQsIGhlbHBlcnMpO1xuICB9O1xufVxudmFyIGxvZ1RodW5rRXZlbnRMaXN0ZW5lckVycm9yID0gZnVuY3Rpb24gbG9nVGh1bmtFdmVudExpc3RlbmVyRXJyb3IodHlwZSwgZXJyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUubG9nKFwiRXJyb3IgaW4gXCIgKyB0eXBlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS5sb2coZXJyKTtcbn07XG52YXIgaGFuZGxlRXZlbnREaXNwYXRjaEVycm9ycyQxID0gZnVuY3Rpb24gaGFuZGxlRXZlbnREaXNwYXRjaEVycm9ycyh0eXBlLCBkaXNwYXRjaGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXN1bHQgPSBkaXNwYXRjaGVyLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGxvZ1RodW5rRXZlbnRMaXN0ZW5lckVycm9yKHR5cGUsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nVGh1bmtFdmVudExpc3RlbmVyRXJyb3IodHlwZSwgZXJyKTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtBY3Rpb25zQ3JlYXRvcihkZWYsIF9yKSB7XG4gIHZhciBhY3Rpb25DcmVhdG9yID0gZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihwYXlsb2FkKSB7XG4gICAgdmFyIGRpc3BhdGNoU3RhcnQgPSBoYW5kbGVFdmVudERpc3BhdGNoRXJyb3JzJDEoZGVmLm1ldGEuc3RhcnRUeXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3IuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBkZWYubWV0YS5zdGFydFR5cGUsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBkaXNwYXRjaEZhaWwgPSBoYW5kbGVFdmVudERpc3BhdGNoRXJyb3JzJDEoZGVmLm1ldGEuZmFpbFR5cGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJldHVybiBfci5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGRlZi5tZXRhLmZhaWxUeXBlLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgZGlzcGF0Y2hTdWNjZXNzID0gaGFuZGxlRXZlbnREaXNwYXRjaEVycm9ycyQxKGRlZi5tZXRhLnN1Y2Nlc3NUeXBlLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gX3IuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBkZWYubWV0YS5zdWNjZXNzVHlwZSxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRpc3BhdGNoU3RhcnQoKTtcbiAgICB2YXIgZmFpbHVyZSA9IG51bGw7XG4gICAgdmFyIGZhaWwgPSBmdW5jdGlvbiBmYWlsKF9mYWlsdXJlKSB7XG4gICAgICBmYWlsdXJlID0gX2ZhaWx1cmUgfHwgbmV3IEVycm9yKCk7XG4gICAgfTtcbiAgICB2YXIgcmVzdWx0ID0gX3IuZGlzcGF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlZi50aHVua0hhbmRsZXIocGF5bG9hZCwgZmFpbCk7XG4gICAgfSk7XG4gICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgZGlzcGF0Y2hGYWlsKGZhaWx1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3BhdGNoU3VjY2VzcyhyZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICBkaXNwYXRjaEZhaWwoZmFpbHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3BhdGNoU3VjY2VzcyhyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSBkZWYubWV0YS50eXBlO1xuICBhY3Rpb25DcmVhdG9yLnN1Y2Nlc3NUeXBlID0gZGVmLm1ldGEuc3VjY2Vzc1R5cGU7XG4gIGFjdGlvbkNyZWF0b3IuZmFpbFR5cGUgPSBkZWYubWV0YS5mYWlsVHlwZTtcbiAgYWN0aW9uQ3JlYXRvci5zdGFydFR5cGUgPSBkZWYubWV0YS5zdGFydFR5cGU7XG4gIHJldHVybiBhY3Rpb25DcmVhdG9yO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUoX3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICAgIGlmIChhY3Rpb24gJiYgX3IuX2kuX2xBTVthY3Rpb24udHlwZV0gJiYgX3IuX2kuX2xBTVthY3Rpb24udHlwZV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBzb3VyY2VBY3Rpb24gPSBfci5faS5fYUNEW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICBfci5faS5fbEFNW2FjdGlvbi50eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb25DcmVhdG9yKSB7XG4gICAgICAgICAgICBhY3Rpb25DcmVhdG9yKHtcbiAgICAgICAgICAgICAgdHlwZTogc291cmNlQWN0aW9uID8gc291cmNlQWN0aW9uLmRlZi5tZXRhLnR5cGUgOiBhY3Rpb24udHlwZSxcbiAgICAgICAgICAgICAgcGF5bG9hZDogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgICAgIGVycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICAgICAgICAgIHJlc3VsdDogYWN0aW9uLnJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJpbmRMaXN0ZW5lcmRlZnMobGlzdGVuZXJkZWZzLCBfYUMsIF9hQ0QsIF9sQU0pIHtcbiAgbGlzdGVuZXJkZWZzLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgIHZhciB0YXJnZXRzID0gZGVmLnRhcmdldFJlc29sdmVyKGdldChkZWYubWV0YS5wYXJlbnQsIF9hQyksIF9hQyk7XG4gICAgdmFyIHRhcmdldFR5cGVzID0gKEFycmF5LmlzQXJyYXkodGFyZ2V0cykgPyB0YXJnZXRzIDogW3RhcmdldHNdKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdGFyZ2V0KSB7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJyAmJiB0YXJnZXQuZGVmLm1ldGEudHlwZSAmJiBfYUNEW3RhcmdldC5kZWYubWV0YS50eXBlXSkge1xuICAgICAgICBpZiAodGFyZ2V0LmRlZi5tZXRhLnN1Y2Nlc3NUeXBlKSB7XG4gICAgICAgICAgYWNjLnB1c2godGFyZ2V0LmRlZi5tZXRhLnN1Y2Nlc3NUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2MucHVzaCh0YXJnZXQuZGVmLm1ldGEudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWNjLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIGRlZi5tZXRhLnJlc29sdmVkVGFyZ2V0cyA9IHRhcmdldFR5cGVzO1xuICAgIHRhcmdldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldFR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lclJlZyA9IF9sQU1bdGFyZ2V0VHlwZV0gfHwgW107XG4gICAgICBsaXN0ZW5lclJlZy5wdXNoKF9hQ0RbZGVmLm1ldGEudHlwZV0pO1xuICAgICAgX2xBTVt0YXJnZXRUeXBlXSA9IGxpc3RlbmVyUmVnO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eUJpbmRlcihrZXksIGRlZiwgX3IpIHtcbiAgdmFyIGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgdmFyIHByZXZJbnB1dHMgPSBbXTtcbiAgdmFyIHByZXZWYWx1ZTtcbiAgdmFyIHByZXZTdG9yZVN0YXRlO1xuICB2YXIgcGVyZm9ybWluZ0VxdWFsaXR5Q2hlY2sgPSBmYWxzZTtcbiAgdmFyIGFyZUVxdWFsID0gZnVuY3Rpb24gYXJlRXF1YWwoYSwgYikge1xuICAgIHBlcmZvcm1pbmdFcXVhbGl0eUNoZWNrID0gdHJ1ZTtcbiAgICB2YXIgcmVzdWx0ID0gZXF1YWwoYSwgYik7XG4gICAgcGVyZm9ybWluZ0VxdWFsaXR5Q2hlY2sgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnRTdGF0ZSwgc3RvcmVTdGF0ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnRTdGF0ZSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmIChwZXJmb3JtaW5nRXF1YWxpdHlDaGVjaykge1xuICAgICAgICAgIHJldHVybiBwcmV2VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0cyA9IGRlZi5zdGF0ZVJlc29sdmVycy5tYXAoZnVuY3Rpb24gKHJlc29sdmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVyKHBhcmVudFN0YXRlLCBzdG9yZVN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNSdW5PbmNlICYmIChzdG9yZVN0YXRlID09PSBwcmV2U3RvcmVTdGF0ZSAmJiBhcmVJbnB1dHNFcXVhbChpbnB1dHMsIHByZXZJbnB1dHMpIHx8XG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgY29tcHV0ZWQgcHJvcGVydGllcyByZXNvbHZlZCBldmVyeSB0aW1lIGFuIGFjdGlvblxuICAgICAgICAvLyBpcyBoYW5kbGVkIGJ5IHRoZSByZWR1Y2VyLiBUaGV5IG5lZWQgdG8gcmVtYWluIGxhenksIG9ubHkgYmVpbmdcbiAgICAgICAgLy8gY29tcHV0ZWQgd2hlbiB1c2VkIGJ5IGEgY29tcG9uZW50IG9yIGdldFN0YXRlIGNhbGw7XG4gICAgICAgIF9yLl9pLl9jUy5pc0luUmVkdWNlciAmJlxuICAgICAgICAvLyBUaGlzIGlzIHRvIGFjY291bnQgZm9yIHN0cmFuZ2UgZXJyb3JzIHRoYXQgbWF5IG9jY3VyIHZpYSBpbW1lcjtcbiAgICAgICAgbmV3IEVycm9yKCkuc3RhY2subWF0Y2goL3NoYWxsb3dDb3B5L2dpKSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGRlZi5mbi5hcHBseShkZWYsIGlucHV0cyk7XG4gICAgICAgIGlmICghYXJlRXF1YWwobmV3VmFsdWUsIHByZXZWYWx1ZSkpIHtcbiAgICAgICAgICBwcmV2VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2SW5wdXRzID0gaW5wdXRzO1xuICAgICAgICBwcmV2U3RvcmVTdGF0ZSA9IHN0b3JlU3RhdGU7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0aWVzTWlkZGxld2FyZShfcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgX3IuX2kuX2NTLmlzSW5SZWR1Y2VyID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgX3IuX2kuX2NTLmlzSW5SZWR1Y2VyID0gZmFsc2U7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVmZmVjdHNNaWRkbGV3YXJlKF9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChfci5faS5fZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2U3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgICAgX3IuX2kuX2UuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgICAgICB2YXIgcHJldkxvY2FsID0gZ2V0KGRlZi5tZXRhLnBhcmVudCwgcHJldlN0YXRlKTtcbiAgICAgICAgICAgIHZhciBuZXh0TG9jYWwgPSBnZXQoZGVmLm1ldGEucGFyZW50LCBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgdmFyIHByZXZEZXBlbmRlbmNpZXMgPSBkZWYuZGVwZW5kZW5jeVJlc29sdmVycy5tYXAoZnVuY3Rpb24gKHJlc29sdmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcihwcmV2TG9jYWwsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBuZXh0RGVwZW5kZW5jaWVzID0gZGVmLmRlcGVuZGVuY3lSZXNvbHZlcnMubWFwKGZ1bmN0aW9uIChyZXNvbHZlcikge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXIobmV4dExvY2FsLCBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaGFzQ2hhbmdlZCA9IHByZXZEZXBlbmRlbmNpZXMuc29tZShmdW5jdGlvbiAoZGVwZW5kZW5jeSwgaWR4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5ICE9PSBuZXh0RGVwZW5kZW5jaWVzW2lkeF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIGRlZi5hY3Rpb25DcmVhdG9yKHByZXZEZXBlbmRlbmNpZXMsIG5leHREZXBlbmRlbmNpZXMsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cbnZhciBsb2dFZmZlY3RFcnJvciA9IGZ1bmN0aW9uIGxvZ0VmZmVjdEVycm9yKGVycikge1xuICAvLyBBcyB1c2VycyBjYW4ndCBnZXQgYSBoYW5kbGUgb24gZWZmZWN0cyB3ZSBuZWVkIHRvIHJlcG9ydCB0aGUgZXJyb3JcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS5lcnJvcihlcnIpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUVmZmVjdEhhbmRsZXIoZGVmLCBfciwgaW5qZWN0aW9ucywgX2FDKSB7XG4gIHZhciBkaXNwb3NlO1xuICByZXR1cm4gZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgIHZhciBoZWxwZXJzID0ge1xuICAgICAgZGlzcGF0Y2g6IF9yLmRpc3BhdGNoLFxuICAgICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gZ2V0KGRlZi5tZXRhLnBhcmVudCwgX3IuZ2V0U3RhdGUoKSk7XG4gICAgICB9LFxuICAgICAgZ2V0U3RvcmVBY3Rpb25zOiBmdW5jdGlvbiBnZXRTdG9yZUFjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfYUM7XG4gICAgICB9LFxuICAgICAgZ2V0U3RvcmVTdGF0ZTogX3IuZ2V0U3RhdGUsXG4gICAgICBpbmplY3Rpb25zOiBpbmplY3Rpb25zLFxuICAgICAgbWV0YToge1xuICAgICAgICBrZXk6IGRlZi5tZXRhLmFjdGlvbk5hbWUsXG4gICAgICAgIHBhcmVudDogZGVmLm1ldGEucGFyZW50LFxuICAgICAgICBwYXRoOiBkZWYubWV0YS5wYXRoXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoZGlzcG9zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZGlzcG9zZVJlc3VsdCA9IGRpc3Bvc2UoKTtcbiAgICAgIGRpc3Bvc2UgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaXNQcm9taXNlKGRpc3Bvc2VSZXN1bHQpKSB7XG4gICAgICAgIGRpc3Bvc2VSZXN1bHQuY2F0Y2gobG9nRWZmZWN0RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYWN0aW9ucyA9IGdldChkZWYubWV0YS5wYXJlbnQsIF9hQyk7XG4gICAgdmFyIGVmZmVjdFJlc3VsdCA9IGRlZi5mbihhY3Rpb25zLCBjaGFuZ2UsIGhlbHBlcnMpO1xuICAgIGlmIChpc1Byb21pc2UoZWZmZWN0UmVzdWx0KSkge1xuICAgICAgcmV0dXJuIGVmZmVjdFJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIERpc3Bvc2UgZnVuY3Rpb25zIGFyZSBub3QgYWxsb3dlZCB0byBiZSByZXNvbHZlZCBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgIC8vIERvaW5nIHNvIHdvdWxkIHByb3ZpZGUgaW5jb25zaXN0ZW50IGJlaGF2aW91ciBhcm91bmQgdGhlaXIgZXhlY3V0aW9uLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW2Vhc3ktcGVhc3ldIEVmZmVjdCBpcyBhc3luY2hyb25vdXNseSByZXNvbHZpbmcgYSBkaXNwb3NlIGZuLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZWZmZWN0UmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkaXNwb3NlID0gZWZmZWN0UmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xufVxudmFyIGxvZ0VmZmVjdEV2ZW50TGlzdGVuZXJFcnJvciA9IGZ1bmN0aW9uIGxvZ0VmZmVjdEV2ZW50TGlzdGVuZXJFcnJvcih0eXBlLCBlcnIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS5sb2coXCJFcnJvciBpbiBcIiArIHR5cGUpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmxvZyhlcnIpO1xufTtcbnZhciBoYW5kbGVFdmVudERpc3BhdGNoRXJyb3JzID0gZnVuY3Rpb24gaGFuZGxlRXZlbnREaXNwYXRjaEVycm9ycyh0eXBlLCBkaXNwYXRjaGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXN1bHQgPSBkaXNwYXRjaGVyLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGxvZ0VmZmVjdEV2ZW50TGlzdGVuZXJFcnJvcih0eXBlLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ0VmZmVjdEV2ZW50TGlzdGVuZXJFcnJvcih0eXBlLCBlcnIpO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBjcmVhdGVFZmZlY3RBY3Rpb25zQ3JlYXRvcihkZWYsIF9yLCBlZmZlY3RIYW5kbGVyKSB7XG4gIHZhciBhY3Rpb25DcmVhdG9yID0gZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihwcmV2aW91c0RlcGVuZGVuY2llcywgbmV4dERlcGVuZGVuY2llcywgYWN0aW9uKSB7XG4gICAgdmFyIGNoYW5nZSA9IHtcbiAgICAgIHByZXY6IHByZXZpb3VzRGVwZW5kZW5jaWVzLFxuICAgICAgY3VycmVudDogbmV4dERlcGVuZGVuY2llcyxcbiAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgfTtcbiAgICB2YXIgZGlzcGF0Y2hTdGFydCA9IGhhbmRsZUV2ZW50RGlzcGF0Y2hFcnJvcnMoZGVmLm1ldGEuc3RhcnRUeXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3IuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBkZWYubWV0YS5zdGFydFR5cGUsXG4gICAgICAgIGNoYW5nZTogY2hhbmdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgZGlzcGF0Y2hTdWNjZXNzID0gaGFuZGxlRXZlbnREaXNwYXRjaEVycm9ycyhkZWYubWV0YS5zdWNjZXNzVHlwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9yLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogZGVmLm1ldGEuc3VjY2Vzc1R5cGUsXG4gICAgICAgIGNoYW5nZTogY2hhbmdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaFN0YXJ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXN1bHQgPSBfci5kaXNwYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlZmZlY3RIYW5kbGVyKGNoYW5nZSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgICAgZGlzcGF0Y2hTdWNjZXNzKHJlc29sdmVkKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgIH0sIGxvZ0VmZmVjdEVycm9yKTtcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoU3VjY2VzcyhyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ0VmZmVjdEVycm9yKGVycik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG4gIGFjdGlvbkNyZWF0b3IudHlwZSA9IGRlZi5tZXRhLnR5cGU7XG4gIGFjdGlvbkNyZWF0b3Iuc3RhcnRUeXBlID0gZGVmLm1ldGEuc3RhcnRUeXBlO1xuICBhY3Rpb25DcmVhdG9yLnN1Y2Nlc3NUeXBlID0gZGVmLm1ldGEuc3VjY2Vzc1R5cGU7XG4gIGFjdGlvbkNyZWF0b3IuZmFpbFR5cGUgPSBkZWYubWV0YS5mYWlsVHlwZTtcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhRnJvbU1vZGVsKG1vZGVsLCBpbml0aWFsU3RhdGUsIGluamVjdGlvbnMsIF9yKSB7XG4gIHZhciBfZFMgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBfYUNEID0ge307XG4gIHZhciBfYUMgPSB7fTtcbiAgdmFyIF9hUkQgPSB7fTtcbiAgdmFyIGFjdGlvblRodW5rcyA9IHt9O1xuICB2YXIgX2NQID0gW107XG4gIHZhciBfY1IgPSBbXTtcbiAgdmFyIF9lID0gW107XG4gIHZhciBfbEFDID0ge307XG4gIHZhciBfbEFNID0ge307XG4gIHZhciBsaXN0ZW5lcmRlZnMgPSBbXTtcbiAgdmFyIF9wZXJzaXN0ZW5jZUNvbmZpZyA9IFtdO1xuICB2YXIgX2NTID0ge1xuICAgIGlzSW5SZWR1Y2VyOiBmYWxzZVxuICB9O1xuICB2YXIgcmVjdXJzaXZlRXh0cmFjdEZyb21Nb2RlbCA9IGZ1bmN0aW9uIHJlY3Vyc2l2ZUV4dHJhY3RGcm9tTW9kZWwoY3VycmVudCwgcGFyZW50UGF0aCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhjdXJyZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGN1cnJlbnRba2V5XTtcbiAgICAgIHZhciBwYXRoID0gW10uY29uY2F0KHBhcmVudFBhdGgsIFtrZXldKTtcbiAgICAgIHZhciBtZXRhID0ge1xuICAgICAgICBwYXJlbnQ6IHBhcmVudFBhdGgsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGtleToga2V5XG4gICAgICB9O1xuICAgICAgdmFyIGhhbmRsZVZhbHVlQXNTdGF0ZSA9IGZ1bmN0aW9uIGhhbmRsZVZhbHVlQXNTdGF0ZSgpIHtcbiAgICAgICAgdmFyIGluaXRpYWxQYXJlbnRSZWYgPSBnZXQocGFyZW50UGF0aCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgaWYgKGluaXRpYWxQYXJlbnRSZWYgJiYga2V5IGluIGluaXRpYWxQYXJlbnRSZWYpIHtcbiAgICAgICAgICBzZXQocGF0aCwgX2RTLCBpbml0aWFsUGFyZW50UmVmW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldChwYXRoLCBfZFMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChrZXkgPT09IHBlcnNpc3RTeW1ib2wpIHtcbiAgICAgICAgX3BlcnNpc3RlbmNlQ29uZmlnLnB1c2goZXh0cmFjdFBlcnNpc3RDb25maWcocGFyZW50UGF0aCwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodmFsdWVbYWN0aW9uU3ltYm9sXSB8fCB2YWx1ZVthY3Rpb25PblN5bWJvbF0pIHtcbiAgICAgICAgICB2YXIgZGVmID0gX29iamVjdFNwcmVhZCh7fSwgdmFsdWUpO1xuXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjYXRlZ29yeSBvZiB0aGUgYWN0aW9uXG4gICAgICAgICAgdmFyIGNhdGVnb3J5ID0gZGVmW2FjdGlvblN5bWJvbF0gPyAnQGFjdGlvbicgOiAnQGFjdGlvbk9uJztcblxuICAgICAgICAgIC8vIEVzdGFibGlzaCB0aGUgbWV0YSBkYXRhIGRlc2NyaWJpbmcgdGhlIGFjdGlvblxuICAgICAgICAgIGRlZi5tZXRhID0ge1xuICAgICAgICAgICAgYWN0aW9uTmFtZTogbWV0YS5rZXksXG4gICAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcnksXG4gICAgICAgICAgICB0eXBlOiBjYXRlZ29yeSArIFwiLlwiICsgbWV0YS5wYXRoLmpvaW4oJy4nKSxcbiAgICAgICAgICAgIHBhcmVudDogbWV0YS5wYXJlbnQsXG4gICAgICAgICAgICBwYXRoOiBtZXRhLnBhdGhcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBcImFjdGlvbiBjcmVhdG9yXCIgZnVuY3Rpb25cbiAgICAgICAgICBkZWYuYWN0aW9uQ3JlYXRvciA9IGNyZWF0ZUFjdGlvbkNyZWF0b3IoZGVmLCBfcik7XG5cbiAgICAgICAgICAvLyBDcmVhdGUgYSBiaWRpcmVjdGlvbmFsIHJlbGF0aW9uc2hpcCBvZiB0aGUgZGVmL2FjdGlvbkNyZWF0b3JcbiAgICAgICAgICBkZWYuYWN0aW9uQ3JlYXRvci5kZWYgPSBkZWY7XG5cbiAgICAgICAgICAvLyBDcmVhdGUgYSBiaWRpcmVjdGlvbmFsIHJlbGF0aW9uc2hpcCBvZiB0aGUgZGVmL3JlZHVjZXJcbiAgICAgICAgICBkZWYuZm4uZGVmID0gZGVmO1xuXG4gICAgICAgICAgLy8gQWRkIHRoZSBhY3Rpb24gY3JlYXRvciB0byBsb29rdXAgbWFwXG4gICAgICAgICAgX2FDRFtkZWYubWV0YS50eXBlXSA9IGRlZi5hY3Rpb25DcmVhdG9yO1xuXG4gICAgICAgICAgLy8gQWRkIHRoZSByZWR1Y2VyIHRvIGxvb2t1cCBtYXBcbiAgICAgICAgICBfYVJEW2RlZi5tZXRhLnR5cGVdID0gZGVmLmZuO1xuXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBleHBvc2UgdGhlIGludGVybmFsIGFjdGlvbiB0byBjb25zdW1lcnNcbiAgICAgICAgICBpZiAobWV0YS5rZXkgIT09ICdlUFJTJykge1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBhY3Rpb24gY3JlYXRvciBpbiB0aGUgXCJhY3Rpb25zXCIgb2JqZWN0IHRyZWUgZm9yXG4gICAgICAgICAgICAvLyBlaXRoZXIgdGhlIGxpc3RlbmVycyBvYmplY3QgdHJlZSwgb3IgdGhlIHN0YW5kYXJkIGFjdGlvbnMvdGh1bmtzXG4gICAgICAgICAgICAvLyBvYmplY3QgdHJlZVxuICAgICAgICAgICAgaWYgKGRlZlthY3Rpb25PblN5bWJvbF0pIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXJkZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgc2V0KHBhdGgsIF9sQUMsIGRlZi5hY3Rpb25DcmVhdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldChwYXRoLCBfYUMsIGRlZi5hY3Rpb25DcmVhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWVbdGh1bmtTeW1ib2xdIHx8IHZhbHVlW3RodW5rT25TeW1ib2xdKSB7XG4gICAgICAgICAgdmFyIF9kZWYgPSBfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSk7XG5cbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNhdGVnb3J5IG9mIHRoZSB0aHVua1xuICAgICAgICAgIHZhciBfY2F0ZWdvcnkgPSBfZGVmW3RodW5rU3ltYm9sXSA/ICdAdGh1bmsnIDogJ0B0aHVua09uJztcblxuICAgICAgICAgIC8vIEVzdGFibGlzaCB0aGUgbWV0YSBkYXRhIGRlc2NyaWJpbmcgdGhlIHRodW5rXG4gICAgICAgICAgdmFyIHR5cGUgPSBfY2F0ZWdvcnkgKyBcIi5cIiArIG1ldGEucGF0aC5qb2luKCcuJyk7XG4gICAgICAgICAgX2RlZi5tZXRhID0ge1xuICAgICAgICAgICAgYWN0aW9uTmFtZTogbWV0YS5rZXksXG4gICAgICAgICAgICBwYXJlbnQ6IG1ldGEucGFyZW50LFxuICAgICAgICAgICAgcGF0aDogbWV0YS5wYXRoLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHN0YXJ0VHlwZTogdHlwZSArIFwiKHN0YXJ0KVwiLFxuICAgICAgICAgICAgc3VjY2Vzc1R5cGU6IHR5cGUgKyBcIihzdWNjZXNzKVwiLFxuICAgICAgICAgICAgZmFpbFR5cGU6IHR5cGUgKyBcIihmYWlsKVwiXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGhhbmRsZSwgaS5lLiBiZSBleGVjdXRlZCwgd2hlblxuICAgICAgICAgIC8vIHRoZSB0aHVuayBhY3Rpb24gaXMgY3JlYXRlZC9kaXNwYXRjaGVkXG4gICAgICAgICAgX2RlZi50aHVua0hhbmRsZXIgPSBjcmVhdGVUaHVua0hhbmRsZXIoX2RlZiwgX3IsIGluamVjdGlvbnMsIF9hQyk7XG5cbiAgICAgICAgICAvLyBSZWdpc3RlciB0aGUgdGh1bmsgaGFuZGxlclxuICAgICAgICAgIHNldChwYXRoLCBhY3Rpb25UaHVua3MsIF9kZWYudGh1bmtIYW5kbGVyKTtcblxuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgXCJhY3Rpb24gY3JlYXRvclwiIGZ1bmN0aW9uXG4gICAgICAgICAgX2RlZi5hY3Rpb25DcmVhdG9yID0gY3JlYXRlVGh1bmtBY3Rpb25zQ3JlYXRvcihfZGVmLCBfcik7XG5cbiAgICAgICAgICAvLyBDcmVhdGUgYSBiaWRpcmVjdGlvbmFsIHJlbGF0aW9uc2hpcCBvZiB0aGUgZGVmL2FjdGlvbkNyZWF0b3JcbiAgICAgICAgICBfZGVmLmFjdGlvbkNyZWF0b3IuZGVmID0gX2RlZjtcblxuICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBhY3Rpb24gY3JlYXRvciB3aXRoaW4gdGhlIGxvb2t1cCBtYXBcbiAgICAgICAgICBfYUNEW19kZWYubWV0YS50eXBlXSA9IF9kZWYuYWN0aW9uQ3JlYXRvcjtcblxuICAgICAgICAgIC8vIFNldCB0aGUgYWN0aW9uIGNyZWF0b3IgaW4gdGhlIFwiYWN0aW9uc1wiIG9iamVjdCB0cmVlIGZvclxuICAgICAgICAgIC8vIGVpdGhlciB0aGUgbGlzdGVuZXJzIG9iamVjdCB0cmVlLCBvciB0aGUgc3RhbmRhcmQgYWN0aW9ucy90aHVua3NcbiAgICAgICAgICAvLyBvYmplY3QgdHJlZVxuICAgICAgICAgIGlmIChfZGVmW3RodW5rT25TeW1ib2xdKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcmRlZnMucHVzaChfZGVmKTtcbiAgICAgICAgICAgIHNldChwYXRoLCBfbEFDLCBfZGVmLmFjdGlvbkNyZWF0b3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQocGF0aCwgX2FDLCBfZGVmLmFjdGlvbkNyZWF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVtjb21wdXRlZFN5bWJvbF0pIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0KHBhcmVudFBhdGgsIF9kUyk7XG4gICAgICAgICAgdmFyIGJpbmRDb21wdXRlZFByb3BlcnR5ID0gY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eUJpbmRlcihrZXksIHZhbHVlLCBfcik7XG4gICAgICAgICAgYmluZENvbXB1dGVkUHJvcGVydHkocGFyZW50LCBfZFMpO1xuICAgICAgICAgIF9jUC5wdXNoKHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgcGFyZW50UGF0aDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIGJpbmRDb21wdXRlZFByb3BlcnR5OiBiaW5kQ29tcHV0ZWRQcm9wZXJ0eVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlW3JlZHVjZXJTeW1ib2xdKSB7XG4gICAgICAgICAgX2NSLnB1c2goe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICBwYXJlbnRQYXRoOiBwYXJlbnRQYXRoLFxuICAgICAgICAgICAgcmVkdWNlcjogdmFsdWUuZm4sXG4gICAgICAgICAgICBjb25maWc6IHZhbHVlLmNvbmZpZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlW2VmZmVjdE9uU3ltYm9sXSkge1xuICAgICAgICAgIHZhciBfZGVmMiA9IF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKTtcblxuICAgICAgICAgIC8vIEVzdGFibGlzaCB0aGUgbWV0YSBkYXRhIGRlc2NyaWJpbmcgdGhlIGVmZmVjdFxuICAgICAgICAgIHZhciBfdHlwZSA9IFwiQGVmZmVjdE9uLlwiICsgbWV0YS5wYXRoLmpvaW4oJy4nKTtcbiAgICAgICAgICBfZGVmMi5tZXRhID0ge1xuICAgICAgICAgICAgdHlwZTogX3R5cGUsXG4gICAgICAgICAgICBhY3Rpb25OYW1lOiBtZXRhLmtleSxcbiAgICAgICAgICAgIHBhcmVudDogbWV0YS5wYXJlbnQsXG4gICAgICAgICAgICBwYXRoOiBtZXRhLnBhdGgsXG4gICAgICAgICAgICBzdGFydFR5cGU6IF90eXBlICsgXCIoc3RhcnQpXCIsXG4gICAgICAgICAgICBzdWNjZXNzVHlwZTogX3R5cGUgKyBcIihzdWNjZXNzKVwiLFxuICAgICAgICAgICAgZmFpbFR5cGU6IF90eXBlICsgXCIoZmFpbClcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGVmZmVjdEhhbmRsZXIgPSBjcmVhdGVFZmZlY3RIYW5kbGVyKF9kZWYyLCBfciwgaW5qZWN0aW9ucywgX2FDKTtcbiAgICAgICAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGNyZWF0ZUVmZmVjdEFjdGlvbnNDcmVhdG9yKF9kZWYyLCBfciwgZWZmZWN0SGFuZGxlcik7XG4gICAgICAgICAgX2RlZjIuYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3I7XG4gICAgICAgICAgX2UucHVzaChfZGVmMik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBnZXQocGF0aCwgX2RTKTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0KHBhdGgsIF9kUywge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWN1cnNpdmVFeHRyYWN0RnJvbU1vZGVsKHZhbHVlLCBwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVWYWx1ZUFzU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlVmFsdWVBc1N0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIF9wZXJzaXN0ZW5jZUNvbmZpZyA9IF9wZXJzaXN0ZW5jZUNvbmZpZy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGFQYXRoID0gYS5wYXRoLmpvaW4oJy4nKTtcbiAgICB2YXIgYlBhdGggPSBiLnBhdGguam9pbignLicpO1xuICAgIGlmIChhUGF0aCA8IGJQYXRoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChhUGF0aCA+IGJQYXRoKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xuICByZWN1cnNpdmVFeHRyYWN0RnJvbU1vZGVsKG1vZGVsLCBbXSk7XG4gIGJpbmRMaXN0ZW5lcmRlZnMobGlzdGVuZXJkZWZzLCBfYUMsIF9hQ0QsIF9sQU0pO1xuICByZXR1cm4ge1xuICAgIF9hQ0Q6IF9hQ0QsXG4gICAgX2FDOiBfYUMsXG4gICAgX2FSRDogX2FSRCxcbiAgICBfY1A6IF9jUCxcbiAgICBfY1I6IF9jUixcbiAgICBfY1M6IF9jUyxcbiAgICBfZFM6IF9kUyxcbiAgICBfZTogX2UsXG4gICAgX2xBQzogX2xBQyxcbiAgICBfbEFNOiBfbEFNLFxuICAgIF9wZXJzaXN0ZW5jZUNvbmZpZzogX3BlcnNpc3RlbmNlQ29uZmlnXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKG1vZGVsLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgdmFyIG1vZGVsQ2xvbmUgPSBjbG9uZShtb2RlbCk7XG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgY29tcG9zZSQxID0gX29wdGlvbnMuY29tcG9zZSxcbiAgICBfb3B0aW9ucyRkZXZUb29scyA9IF9vcHRpb25zLmRldlRvb2xzLFxuICAgIGRldlRvb2xzID0gX29wdGlvbnMkZGV2VG9vbHMgPT09IHZvaWQgMCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgOiBfb3B0aW9ucyRkZXZUb29scyxcbiAgICBfb3B0aW9ucyRkaXNhYmxlSW1tZXIgPSBfb3B0aW9ucy5kaXNhYmxlSW1tZXIsXG4gICAgZGlzYWJsZUltbWVyID0gX29wdGlvbnMkZGlzYWJsZUltbWVyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGRpc2FibGVJbW1lcixcbiAgICBfb3B0aW9ucyRlbmhhbmNlcnMgPSBfb3B0aW9ucy5lbmhhbmNlcnMsXG4gICAgZW5oYW5jZXJzID0gX29wdGlvbnMkZW5oYW5jZXJzID09PSB2b2lkIDAgPyBbXSA6IF9vcHRpb25zJGVuaGFuY2VycyxcbiAgICBfb3B0aW9ucyRpbml0aWFsU3RhdGUgPSBfb3B0aW9ucy5pbml0aWFsU3RhdGUsXG4gICAgaW5pdGlhbFN0YXRlID0gX29wdGlvbnMkaW5pdGlhbFN0YXRlID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfb3B0aW9ucyRpbml0aWFsU3RhdGUsXG4gICAgX29wdGlvbnMkaW5qZWN0aW9ucyA9IF9vcHRpb25zLmluamVjdGlvbnMsXG4gICAgaW5qZWN0aW9ucyA9IF9vcHRpb25zJGluamVjdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnMkaW5qZWN0aW9ucyxcbiAgICBfb3B0aW9ucyRtaWRkbGV3YXJlID0gX29wdGlvbnMubWlkZGxld2FyZSxcbiAgICBtaWRkbGV3YXJlID0gX29wdGlvbnMkbWlkZGxld2FyZSA9PT0gdm9pZCAwID8gW10gOiBfb3B0aW9ucyRtaWRkbGV3YXJlLFxuICAgIF9vcHRpb25zJG1vY2tBY3Rpb25zID0gX29wdGlvbnMubW9ja0FjdGlvbnMsXG4gICAgbW9ja0FjdGlvbnMgPSBfb3B0aW9ucyRtb2NrQWN0aW9ucyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRtb2NrQWN0aW9ucyxcbiAgICBfb3B0aW9ucyRuYW1lID0gX29wdGlvbnMubmFtZSxcbiAgICBzdG9yZU5hbWUgPSBfb3B0aW9ucyRuYW1lID09PSB2b2lkIDAgPyBcIkVhc3lQZWFzeVN0b3JlXCIgOiBfb3B0aW9ucyRuYW1lLFxuICAgIF9vcHRpb25zJHZlcnNpb24gPSBfb3B0aW9ucy52ZXJzaW9uLFxuICAgIHZlcnNpb24gPSBfb3B0aW9ucyR2ZXJzaW9uID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdmVyc2lvbixcbiAgICBfb3B0aW9ucyRyZWR1Y2VyRW5oYW4gPSBfb3B0aW9ucy5yZWR1Y2VyRW5oYW5jZXIsXG4gICAgcmVkdWNlckVuaGFuY2VyID0gX29wdGlvbnMkcmVkdWNlckVuaGFuID09PSB2b2lkIDAgPyBmdW5jdGlvbiAocm9vdFJlZHVjZXIpIHtcbiAgICAgIHJldHVybiByb290UmVkdWNlcjtcbiAgICB9IDogX29wdGlvbnMkcmVkdWNlckVuaGFuO1xuICB2YXIgYmluZFJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIGJpbmRSZXBsYWNlU3RhdGUobW9kZWxEZWYpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtb2RlbERlZiksIHt9LCB7XG4gICAgICBlUFJTOiBhY3Rpb24oZnVuY3Rpb24gKF8sIHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9KVxuICAgIH0pO1xuICB9O1xuICB2YXIgX3IgPSB7fTtcbiAgdmFyIG1vZGVsZGVmID0gYmluZFJlcGxhY2VTdGF0ZShtb2RlbENsb25lKTtcbiAgdmFyIG1vY2tlZEFjdGlvbnMgPSBbXTtcbiAgdmFyIHBlcnNpc3RLZXkgPSBmdW5jdGlvbiBwZXJzaXN0S2V5KHRhcmdldFBhdGgpIHtcbiAgICByZXR1cm4gXCJbXCIgKyBzdG9yZU5hbWUgKyBcIl1bXCIgKyB2ZXJzaW9uICsgXCJdXCIgKyAodGFyZ2V0UGF0aC5sZW5ndGggPiAwID8gXCJbXCIgKyB0YXJnZXRQYXRoLmpvaW4oJy4nKSArIFwiXVwiIDogJycpO1xuICB9O1xuICB2YXIgcGVyc2lzdG9yID0gY3JlYXRlUGVyc2lzdG9yKHBlcnNpc3RLZXksIF9yKTtcbiAgdmFyIHBlcnNpc3RNaWRkbGV3YXJlID0gY3JlYXRlUGVyc2lzdE1pZGRsZXdhcmUocGVyc2lzdG9yLCBfcik7XG4gIHZhciByZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiByZXBsYWNlU3RhdGUobmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuIF9yLl9pLl9hQ0RbJ0BhY3Rpb24uZVBSUyddKG5leHRTdGF0ZSk7XG4gIH07XG4gIHZhciBiaW5kU3RvcmVJbnRlcm5hbHMgPSBmdW5jdGlvbiBiaW5kU3RvcmVJbnRlcm5hbHMoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSB7fTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBleHRyYWN0RGF0YUZyb21Nb2RlbChtb2RlbGRlZiwgc3RhdGUsIGluamVjdGlvbnMsIF9yKTtcbiAgICBfci5faSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGF0YSksIHt9LCB7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyRW5oYW5jZXIoY3JlYXRlUmVkdWNlcihkaXNhYmxlSW1tZXIsIGRhdGEuX2FSRCwgZGF0YS5fY1IsIGRhdGEuX2NQKSlcbiAgICB9KTtcbiAgfTtcbiAgdmFyIG1vY2tBY3Rpb25zTWlkZGxld2FyZSA9IGZ1bmN0aW9uIG1vY2tBY3Rpb25zTWlkZGxld2FyZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgbW9ja2VkQWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbiAgdmFyIGRldlRvb2xDb25maWcgPSBkZXZUb29scyA9PT0gdHJ1ZSA/IHt9IDogZGV2VG9vbHM7XG4gIHZhciBjb21wb3NlRW5oYW5jZXJzID0gY29tcG9zZSQxIHx8IChkZXZUb29scyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyhfb2JqZWN0U3ByZWFkKHtcbiAgICBuYW1lOiBzdG9yZU5hbWVcbiAgfSwgZGV2VG9vbENvbmZpZykpIDogY29tcG9zZSk7XG4gIGJpbmRTdG9yZUludGVybmFscyhpbml0aWFsU3RhdGUgfHwge30pO1xuICB2YXIgZWFzeVBlYXN5TWlkZGxld2FyZSA9IFtjcmVhdGVDb21wdXRlZFByb3BlcnRpZXNNaWRkbGV3YXJlKF9yKV0uY29uY2F0KG1pZGRsZXdhcmUsIFtyZWR1eFRodW5rLCBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUoX3IpLCBjcmVhdGVFZmZlY3RzTWlkZGxld2FyZShfciksIHBlcnNpc3RNaWRkbGV3YXJlXSk7XG4gIGlmIChtb2NrQWN0aW9ucykge1xuICAgIGVhc3lQZWFzeU1pZGRsZXdhcmUucHVzaChtb2NrQWN0aW9uc01pZGRsZXdhcmUpO1xuICB9XG4gIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlJDEoX3IuX2kucmVkdWNlciwgX3IuX2kuX2RTLCBjb21wb3NlRW5oYW5jZXJzLmFwcGx5KHZvaWQgMCwgW2FwcGx5TWlkZGxld2FyZS5hcHBseSh2b2lkIDAsIGVhc3lQZWFzeU1pZGRsZXdhcmUpXS5jb25jYXQoZW5oYW5jZXJzKSkpO1xuICBzdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgIF9yLl9pLl9jUy5pc0luUmVkdWNlciA9IGZhbHNlO1xuICB9KTtcbiAgX3IuZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgX3IuZ2V0U3RhdGUgPSBzdG9yZS5nZXRTdGF0ZTtcbiAgdmFyIGJpbmRBY3Rpb25DcmVhdG9ycyA9IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycygpIHtcbiAgICBPYmplY3Qua2V5cyhzdG9yZS5kaXNwYXRjaCkuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uc0tleSkge1xuICAgICAgZGVsZXRlIHN0b3JlLmRpc3BhdGNoW2FjdGlvbnNLZXldO1xuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKF9yLl9pLl9hQykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBzdG9yZS5kaXNwYXRjaFtrZXldID0gX3IuX2kuX2FDW2tleV07XG4gICAgfSk7XG4gIH07XG4gIGJpbmRBY3Rpb25DcmVhdG9ycygpO1xuICB2YXIgcmViaW5kU3RvcmUgPSBmdW5jdGlvbiByZWJpbmRTdG9yZShyZW1vdmVLZXkpIHtcbiAgICB2YXIgY3VycmVudFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAocmVtb3ZlS2V5KSB7XG4gICAgICBkZWxldGUgY3VycmVudFN0YXRlW3JlbW92ZUtleV07XG4gICAgfVxuICAgIGJpbmRTdG9yZUludGVybmFscyhjdXJyZW50U3RhdGUpO1xuICAgIHN0b3JlLnJlcGxhY2VSZWR1Y2VyKF9yLl9pLnJlZHVjZXIpO1xuICAgIHJlcGxhY2VTdGF0ZShfci5faS5fZFMpO1xuICAgIGJpbmRBY3Rpb25DcmVhdG9ycygpO1xuICB9O1xuICB2YXIgX3Jlc29sdmVSZWh5ZHJhdGlvbiA9IHJlaHlkcmF0ZVN0YXRlRnJvbVBlcnNpc3RJZk5lZWRlZChwZXJzaXN0S2V5LCByZXBsYWNlU3RhdGUsIF9yKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3RvcmUsIHtcbiAgICBhZGRNb2RlbDogZnVuY3Rpb24gYWRkTW9kZWwoa2V5LCBtb2RlbEZvcktleSkge1xuICAgICAgaWYgKG1vZGVsZGVmW2tleV0gJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzdG9yZS5yZW1vdmVNb2RlbChrZXkpO1xuICAgICAgfVxuICAgICAgbW9kZWxkZWZba2V5XSA9IG1vZGVsRm9yS2V5O1xuICAgICAgcmViaW5kU3RvcmUoKTtcbiAgICAgIC8vIFRoZXJlIG1heSBoYXZlIGJlZW4gcGVyc2lzdGVkIHN0YXRlIGZvciBhIGR5bmFtaWMgbW9kZWwuIFdlIHNob3VsZCB0cnlcbiAgICAgIC8vIGFuZCByZWh5ZHJhdGUgdGhlIHNwZWNpZmMgbm9kZVxuICAgICAgdmFyIGFkZE1vZGVsUmVoeWRyYXRpb24gPSByZWh5ZHJhdGVTdGF0ZUZyb21QZXJzaXN0SWZOZWVkZWQocGVyc2lzdEtleSwgcmVwbGFjZVN0YXRlLCBfciwga2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc29sdmVSZWh5ZHJhdGlvbjogZnVuY3Rpb24gcmVzb2x2ZVJlaHlkcmF0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhZGRNb2RlbFJlaHlkcmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgY2xlYXJNb2NrZWRBY3Rpb25zOiBmdW5jdGlvbiBjbGVhck1vY2tlZEFjdGlvbnMoKSB7XG4gICAgICBtb2NrZWRBY3Rpb25zID0gW107XG4gICAgfSxcbiAgICBnZXRBY3Rpb25zOiBmdW5jdGlvbiBnZXRBY3Rpb25zKCkge1xuICAgICAgcmV0dXJuIF9yLl9pLl9hQztcbiAgICB9LFxuICAgIGdldExpc3RlbmVyczogZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIF9yLl9pLl9sQUM7XG4gICAgfSxcbiAgICBnZXRNb2NrZWRBY3Rpb25zOiBmdW5jdGlvbiBnZXRNb2NrZWRBY3Rpb25zKCkge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChtb2NrZWRBY3Rpb25zKTtcbiAgICB9LFxuICAgIHBlcnNpc3Q6IHtcbiAgICAgIGNsZWFyOiBwZXJzaXN0b3IuY2xlYXIsXG4gICAgICBmbHVzaDogcGVyc2lzdG9yLmZsdXNoLFxuICAgICAgcmVzb2x2ZVJlaHlkcmF0aW9uOiBmdW5jdGlvbiByZXNvbHZlUmVoeWRyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVzb2x2ZVJlaHlkcmF0aW9uO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVjb25maWd1cmU6IGZ1bmN0aW9uIHJlY29uZmlndXJlKG5ld01vZGVsKSB7XG4gICAgICBtb2RlbGRlZiA9IGJpbmRSZXBsYWNlU3RhdGUobmV3TW9kZWwpO1xuICAgICAgcmViaW5kU3RvcmUoKTtcbiAgICB9LFxuICAgIHJlbW92ZU1vZGVsOiBmdW5jdGlvbiByZW1vdmVNb2RlbChrZXkpIHtcbiAgICAgIGlmICghbW9kZWxkZWZba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgbW9kZWxkZWZba2V5XTtcbiAgICAgIHJlYmluZFN0b3JlKGtleSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dFN0b3JlKG1vZGVsLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cbiAgLy8gV2UgY3JlYXRlIGEgbXV0YWJsZSBpbmplY3Rpb25zIHJlZmVyZW5jZSB0byBhbGxvdyB1cGRhdGluZyBpdFxuICB2YXIgX2NvbmZpZyA9IGNvbmZpZyxcbiAgICBfY29uZmlnJGluamVjdGlvbnMgPSBfY29uZmlnLmluamVjdGlvbnMsXG4gICAgbXV0YWJsZUluamVjdGlvbnMgPSBfY29uZmlnJGluamVjdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX2NvbmZpZyRpbmplY3Rpb25zO1xuICB2YXIgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuICBmdW5jdGlvbiBQcm92aWRlcihfcmVmKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHJ1bnRpbWVNb2RlbCA9IF9yZWYucnVudGltZU1vZGVsLFxuICAgICAgaW5qZWN0aW9ucyA9IF9yZWYuaW5qZWN0aW9ucztcbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBpbmplY3Rpb25zIHdlIG5lZWQgdG8gZW5zdXJlIG91ciBtdXRhYmxlIHJlZlxuICAgIC8vIGlzIHVwIHRvIGRhdGUuIFdlIGNvdWxkIGNvbnNpZGVyIGRvaW5nIGEgc2hhbGxvdyBjb21wYXJlIGhlcmU/XG4gICAgaWYgKGluamVjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgdmFyIG5leHRJbmplY3Rpb25zID0gdHlwZW9mIGluamVjdGlvbnMgPT09ICdmdW5jdGlvbicgPyBpbmplY3Rpb25zKG11dGFibGVJbmplY3Rpb25zKSA6IGluamVjdGlvbnM7XG4gICAgICB2YXIgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0SW5qZWN0aW9ucyk7XG4gICAgICB2YXIgcmVtb3ZlS2V5cyA9IE9iamVjdC5rZXlzKG11dGFibGVJbmplY3Rpb25zKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuICFuZXh0S2V5cy5pbmNsdWRlcyhrKTtcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGRlbGV0ZSBtdXRhYmxlSW5qZWN0aW9uc1trXTtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihtdXRhYmxlSW5qZWN0aW9ucywgbmV4dEluamVjdGlvbnMpO1xuICAgIH1cbiAgICB2YXIgc3RvcmUgPSB1c2VNZW1vT25lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTdG9yZSh0eXBlb2YgbW9kZWwgPT09ICdmdW5jdGlvbicgPyBtb2RlbChydW50aW1lTW9kZWwpIDogbW9kZWwsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY29uZmlnKSwge30sIHtcbiAgICAgICAgb3JpZ2luYWxJbmplY3Rpb25zOiBtdXRhYmxlSW5qZWN0aW9uc1xuICAgICAgfSkpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3RvcmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogc3RvcmVcbiAgICB9LCBjaGlsZHJlbik7XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFByb3ZpZGVyOiBQcm92aWRlcixcbiAgICB1c2VTdG9yZTogdXNlU3RvcmUsXG4gICAgdXNlU3RvcmVTdGF0ZTogY3JlYXRlU3RvcmVTdGF0ZUhvb2soU3RvcmVDb250ZXh0KSxcbiAgICB1c2VTdG9yZUFjdGlvbnM6IGNyZWF0ZVN0b3JlQWN0aW9uc0hvb2soU3RvcmVDb250ZXh0KSxcbiAgICB1c2VTdG9yZURpc3BhdGNoOiBjcmVhdGVTdG9yZURpc3BhdGNoSG9vayhTdG9yZUNvbnRleHQpLFxuICAgIHVzZVN0b3JlUmVoeWRyYXRlZDogY3JlYXRlU3RvcmVSZWh5ZHJhdGVkSG9vayhTdG9yZUNvbnRleHQpXG4gIH07XG59XG5cbi8qKlxyXG4gKiBUaGlzIGZpbGUgaGFzIGJlZW4gY29waWVkIGZyb20gcmVkdXgtcGVyc2lzdC5cclxuICogVGhlIGludGVudGlvbiBiZWluZyB0byBzdXBwb3J0IGFzIG11Y2ggb2YgdGhlIHJlZHV4LXBlcnNpc3QgQVBJIGFzIHBvc3NpYmxlLlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtKGluYm91bmQsIG91dGJvdW5kLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cbiAgdmFyIHdoaXRlbGlzdCA9IGNvbmZpZy53aGl0ZWxpc3QgfHwgbnVsbDtcbiAgdmFyIGJsYWNrbGlzdCA9IGNvbmZpZy5ibGFja2xpc3QgfHwgbnVsbDtcbiAgZnVuY3Rpb24gd2hpdGVsaXN0QmxhY2tsaXN0Q2hlY2soa2V5KSB7XG4gICAgaWYgKHdoaXRlbGlzdCAmJiB3aGl0ZWxpc3QuaW5kZXhPZihrZXkpID09PSAtMSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGJsYWNrbGlzdCAmJiBibGFja2xpc3QuaW5kZXhPZihrZXkpICE9PSAtMSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB7XG4gICAgaW46IGZ1bmN0aW9uIF9pbihkYXRhLCBrZXksIGZ1bGxTdGF0ZSkge1xuICAgICAgcmV0dXJuICF3aGl0ZWxpc3RCbGFja2xpc3RDaGVjayhrZXkpICYmIGluYm91bmQgPyBpbmJvdW5kKGRhdGEsIGtleSwgZnVsbFN0YXRlKSA6IGRhdGE7XG4gICAgfSxcbiAgICBvdXQ6IGZ1bmN0aW9uIG91dChkYXRhLCBrZXksIGZ1bGxTdGF0ZSkge1xuICAgICAgcmV0dXJuICF3aGl0ZWxpc3RCbGFja2xpc3RDaGVjayhrZXkpICYmIG91dGJvdW5kID8gb3V0Ym91bmQoZGF0YSwga2V5LCBmdWxsU3RhdGUpIDogZGF0YTtcbiAgICB9XG4gIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3Byb3AtdHlwZXMgKi9cbmZ1bmN0aW9uIFN0b3JlUHJvdmlkZXIoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgIHN0b3JlID0gX3JlZi5zdG9yZTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN0b3JlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIHVzZUxvY2FsU3RvcmUobW9kZWxDcmVhdG9yLCBkZXBlbmRlbmNpZXMsIGNvbmZpZ0NyZWF0b3IpIHtcbiAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7XG4gICAgZGVwZW5kZW5jaWVzID0gW107XG4gIH1cbiAgaWYgKGNvbmZpZ0NyZWF0b3IgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZ0NyZWF0b3IgPSBudWxsO1xuICB9XG4gIHZhciBzdG9yZVJlZiA9IHVzZVJlZigpO1xuICB2YXIgY29uZmlnUmVmID0gdXNlUmVmKCk7XG4gIHZhciBzdG9yZSA9IHVzZU1lbW9PbmUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2aW91c1N0YXRlID0gc3RvcmVSZWYuY3VycmVudCAhPSBudWxsID8gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpIDogdW5kZWZpbmVkO1xuICAgIHZhciBjb25maWcgPSBjb25maWdDcmVhdG9yICE9IG51bGwgPyBjb25maWdDcmVhdG9yKHByZXZpb3VzU3RhdGUsIGNvbmZpZ1JlZi5jdXJyZW50KSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX3N0b3JlID0gY3JlYXRlU3RvcmUobW9kZWxDcmVhdG9yKHByZXZpb3VzU3RhdGUpLCBjb25maWcpO1xuICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBfc3RvcmU7XG4gICAgcmV0dXJuIF9zdG9yZTtcbiAgfSwgZGVwZW5kZW5jaWVzKTtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIH0pLFxuICAgIGN1cnJlbnRTdGF0ZSA9IF91c2VTdGF0ZVswXSxcbiAgICBzZXRDdXJyZW50U3RhdGUgPSBfdXNlU3RhdGVbMV07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc2V0Q3VycmVudFN0YXRlKHN0b3JlLmdldFN0YXRlKCkpO1xuICAgIHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV4dFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChjdXJyZW50U3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgICBzZXRDdXJyZW50U3RhdGUobmV4dFN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3N0b3JlXSk7XG4gIHJldHVybiBbY3VycmVudFN0YXRlLCBzdG9yZS5nZXRBY3Rpb25zKCksIHN0b3JlXTtcbn1cblxuLy8gUmVhY3QgMTggcmVxdWlyZXMgdGhlIHVzZSBvZiB0aGUgdXNlU3luY0V4dGVybmFsU3RvcmUgaG9vayBmb3IgZXh0ZXJuYWxcbmluaXRpYWxpemVVc2VTdG9yZVN0YXRlKHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yJDEpO1xuXG5leHBvcnQgeyBTdG9yZVByb3ZpZGVyLCBhY3Rpb24sIGFjdGlvbk9uLCBjb21wdXRlZCwgY3JlYXRlQ29udGV4dFN0b3JlLCBjcmVhdGVTdG9yZSwgY3JlYXRlU3RvcmVBY3Rpb25zSG9vaywgY3JlYXRlU3RvcmVEaXNwYXRjaEhvb2ssIGNyZWF0ZVN0b3JlUmVoeWRyYXRlZEhvb2ssIGNyZWF0ZVN0b3JlU3RhdGVIb29rLCBjcmVhdGVUcmFuc2Zvcm0sIGNyZWF0ZVR5cGVkSG9va3MsIGRlYnVnLCBlZmZlY3RPbiwgZ2VuZXJpYywgaW5pdGlhbGl6ZVVzZVN0b3JlU3RhdGUsIHBlcnNpc3QsIHJlZHVjZXIsIHRodW5rLCB0aHVua09uLCB1c2VMb2NhbFN0b3JlLCB1c2VTdG9yZSwgdXNlU3RvcmVBY3Rpb25zLCB1c2VTdG9yZURpc3BhdGNoLCB1c2VTdG9yZVJlaHlkcmF0ZWQsIHVzZVN0b3JlU3RhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IkMSIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJfb2JqZWN0U3ByZWFkIiwiY29tcG9zZSIsImNyZWF0ZVN0b3JlIiwiY3JlYXRlU3RvcmUkMSIsImFwcGx5TWlkZGxld2FyZSIsInJlZHV4VGh1bmsiLCJpc0RyYWZ0IiwiY3VycmVudCIsIkltbWVyIiwib3JpZ2luYWwiLCJzZXRBdXRvRnJlZXplIiwicHJvZHVjZSIsImVxdWFsIiwiU3RvcmVDb250ZXh0IiwidXNlTm90SW5pdGlhbGl6ZWQiLCJFcnJvciIsImluaXRpYWxpemVVc2VTdG9yZVN0YXRlIiwiZm4iLCJyZWZFcXVhbGl0eSIsImEiLCJiIiwiY3JlYXRlU3RvcmVTdGF0ZUhvb2siLCJDb250ZXh0IiwidXNlU3RvcmVTdGF0ZSIsIm1hcFN0YXRlIiwiZXF1YWxpdHlGbiIsInByb2Nlc3MiLCJzdG9yZSIsInNlbGVjdGVkU3RhdGUiLCJzdWJzY3JpYmUiLCJnZXRTdGF0ZSIsImNyZWF0ZVN0b3JlQWN0aW9uc0hvb2siLCJ1c2VTdG9yZUFjdGlvbnMiLCJtYXBBY3Rpb25zIiwiZ2V0QWN0aW9ucyIsImNyZWF0ZVN0b3JlRGlzcGF0Y2hIb29rIiwidXNlU3RvcmVEaXNwYXRjaCIsImRpc3BhdGNoIiwidXNlU3RvcmUiLCJjcmVhdGVTdG9yZVJlaHlkcmF0ZWRIb29rIiwidXNlU3RvcmVSZWh5ZHJhdGVkIiwiX3VzZVN0YXRlIiwicmVoeWRyYXRlZCIsInNldFJlaHlkcmF0ZWQiLCJwZXJzaXN0IiwicmVzb2x2ZVJlaHlkcmF0aW9uIiwidGhlbiIsImNyZWF0ZVR5cGVkSG9va3MiLCJhY3Rpb25TeW1ib2wiLCJhY3Rpb25PblN5bWJvbCIsImNvbXB1dGVkU3ltYm9sIiwiZWZmZWN0T25TeW1ib2wiLCJwZXJzaXN0U3ltYm9sIiwicmVkdWNlclN5bWJvbCIsInRodW5rT25TeW1ib2wiLCJ0aHVua1N5bWJvbCIsImRlYnVnIiwic3RhdGUiLCJhY3Rpb25PbiIsInRhcmdldFJlc29sdmVyIiwiY29uZmlnIiwiX3JlZiIsImFjdGlvbiIsIl9yZWYyIiwiZGVmYXVsdFN0YXRlUmVzb2x2ZXJzIiwiY29tcHV0ZWQiLCJmbk9yU3RhdGVSZXNvbHZlcnMiLCJfcmVmNCIsIl9yZWYzIiwic3RhdGVSZXNvbHZlcnMiLCJlZmZlY3RPbiIsImRlcGVuZGVuY3lSZXNvbHZlcnMiLCJfcmVmNSIsImdlbmVyaWMiLCJ2YWx1ZSIsIm1vZGVsIiwiX29iamVjdFNwcmVhZDIiLCJ0aHVua09uIiwiX3JlZjYiLCJ0aHVuayIsIl9yZWY3IiwicmVkdWNlciIsIl9yZWY4IiwiZWFzeVBlYXN5SW1tZXIiLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwicHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImNsb25lIiwic291cmNlIiwicmVjdXJzaXZlQ2xvbmUiLCJuZXh0Iiwia2V5cyIsInJlZHVjZSIsImFjYyIsImtleSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImZvckVhY2giLCJpc1Byb21pc2UiLCJ4IiwicGF0aCIsInRhcmdldCIsImN1ciIsInVuZGVmaW5lZCIsIm5ld2lmeSIsImN1cnJlbnRQYXRoIiwiY3VycmVudFN0YXRlIiwiZmluYWxWYWx1ZSIsImxlbmd0aCIsIm5ld1N0YXRlIiwic2xpY2UiLCJzZXQiLCJpZHgiLCJjcmVhdGVTaW1wbGVQcm9kdWNlIiwiZGlzYWJsZUltbWVyIiwic2ltcGxlUHJvZHVjZSIsImltbWVyIiwiX2N1cnJlbnQiLCJ1c2VQcm94aWVzIiwiUHJveHkiLCJyZXZvY2FibGUiLCJSZWZsZWN0IiwiYXV0b0ZyZWV6ZSIsIl9kcmFmdCIsImNyZWF0ZURyYWZ0IiwiX3Jlc3VsdCIsImZpbmlzaERyYWZ0IiwicGFyZW50UGF0aCIsImRyYWZ0IiwicGFyZW50IiwicmVzdWx0IiwicFJlZHVjZSIsIml0ZXJhYmxlIiwiaW5pdGlhbFZhbHVlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpdGVyYXRvciIsIlN5bWJvbCIsImluZGV4IiwidG90YWwiLCJlbGVtZW50IiwiZG9uZSIsImFsbCIsImNhdGNoIiwiZXJyIiwicFNlcmllcyIsInRhc2tzIiwicmVzdWx0cyIsIl8iLCJ0YXNrIiwicHVzaCIsImFyZUlucHV0c0VxdWFsIiwibmV3SW5wdXRzIiwibGFzdElucHV0cyIsImkiLCJ1c2VNZW1vT25lIiwiZ2V0UmVzdWx0IiwiaW5wdXRzIiwiaW5pdGlhbCIsImNvbW1pdHRlZCIsImlzSW5wdXRNYXRjaCIsIkJvb2xlYW4iLCJjYWNoZSIsImNyZWF0ZVJlZHVjZXIiLCJfYVJEIiwiX2NSIiwiX2NQIiwicnVuQWN0aW9uUmVkdWNlckF0UGF0aCIsImFjdGlvblJlZHVjZXIiLCJwYXlsb2FkIiwicmVkdWNlckZvckFjdGlvbnMiLCJ0eXBlIiwiZGVmIiwibWV0YSIsInJlZHVjZXJGb3JDdXN0b21SZWR1Y2VycyIsInJvb3RSZWR1Y2VyIiwic3RhdGVBZnRlckFjdGlvbnMiLCJiaW5kQ29tcHV0ZWRQcm9wZXJ0eSIsInBhcmVudFN0YXRlIiwibWlncmF0ZSIsImRhdGEiLCJtaWdyYXRpb25zIiwiX2RhdGEkX21pZ3JhdGlvblZlcnNpIiwidmVyc2lvbiIsIl9taWdyYXRpb25WZXJzaW9uIiwidG9WZXJzaW9uIiwibWlncmF0aW9uVmVyc2lvbiIsIm5leHRWZXJzaW9uIiwibWlncmF0b3IiLCJub29wU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImdldEJyb3dlclN0b3JhZ2UiLCJzdG9yYWdlTmFtZSIsInN0b3JhZ2VDYWNoZSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsInNlc3Npb25TdG9yYWdlIiwiY3JlYXRlU3RvcmFnZVdyYXBwZXIiLCJzdG9yYWdlIiwidHJhbnNmb3JtZXJzIiwiY29uc29sZSIsIndhcm4iLCJvdXRUcmFuc2Zvcm1lcnMiLCJjb25jYXQiLCJyZXZlcnNlIiwic2VyaWFsaXplIiwiaW4iLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzZXJpYWxpemUiLCJzdG9yYWdlRGF0YSIsInBhcnNlIiwiaGFzTWlncmF0aW9ucyIsIm91dCIsImlzQXN5bmMiLCJ3cmFwcGVkIiwiZXh0cmFjdFBlcnNpc3RDb25maWciLCJwZXJzaXN0ZGVmIiwiYWxsb3ciLCJkZW55IiwibWVyZ2VTdHJhdGVneSIsInJlc29sdmVQZXJzaXN0VGFyZ2V0cyIsInRhcmdldHMiLCJmaW5kSW5kZXgiLCJjcmVhdGVQZXJzaXN0ZW5jZUNsZWFyZXIiLCJwZXJzaXN0S2V5IiwiX3IiLCJfaSIsIl9wZXJzaXN0ZW5jZUNvbmZpZyIsIm1hcCIsImNyZWF0ZVBlcnNpc3RvciIsInBlcnNpc3RQcm9taXNlIiwiaXNQZXJzaXN0aW5nIiwibmV4dFBlcnNpc3RPcGVyYXRpb24iLCJ0aW1pbmdNZXRob2QiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwidGltZW91dCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRTdGF0ZSIsIm9wZXJhdGlvbiIsInBlcnNpc3RSb290U3RhdGUiLCJwZXJzaXN0VGFyZ2V0cyIsInN0YXRlVG9QZXJzaXN0IiwidGFyZ2V0UGF0aCIsInJhd1ZhbHVlIiwiZmluYWxseSIsImNsZWFyIiwiZmx1c2giLCJjcmVhdGVQZXJzaXN0TWlkZGxld2FyZSIsInBlcnNpc3RvciIsInJlaHlkcmF0ZVN0YXRlRnJvbVBlcnNpc3RJZk5lZWRlZCIsInJlcGxhY2VTdGF0ZSIsInJvb3QiLCJfZFMiLCJyZWh5ZHJhdGluZyIsInBlcnNpc3RJbnN0YW5jZSIsImhhc0RhdGFNb2RlbENoYW5nZWQiLCJkYXRhTW9kZWwiLCJyZWh5ZHJhdGluZ01vZGVsRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsImFwcGx5UmVoeWRyYXRpb25TdHJhdGVneSIsInBlcnNpc3RlZFN0YXRlIiwidGFyZ2V0U3RhdGUiLCJfdGFyZ2V0U3RhdGUiLCJzZXRBdCIsImN1cnJlbnRUYXJnZXRTdGF0ZSIsImN1cnJlbnRQZXJzaXN0ZWRTdGF0ZSIsInJlaHlkYXRlIiwiZ2V0SXRlbVJlc3VsdCIsImNyZWF0ZUFjdGlvbkNyZWF0b3IiLCJhY3Rpb25DcmVhdG9yIiwicmVzb2x2ZWRUYXJnZXRzIiwiY3JlYXRlVGh1bmtIYW5kbGVyIiwiaW5qZWN0aW9ucyIsIl9hQyIsImZhaWwiLCJoZWxwZXJzIiwiZ2V0U3RvcmVBY3Rpb25zIiwiZ2V0U3RvcmVTdGF0ZSIsImFjdGlvbk5hbWUiLCJsb2dUaHVua0V2ZW50TGlzdGVuZXJFcnJvciIsImxvZyIsImhhbmRsZUV2ZW50RGlzcGF0Y2hFcnJvcnMkMSIsImhhbmRsZUV2ZW50RGlzcGF0Y2hFcnJvcnMiLCJkaXNwYXRjaGVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjcmVhdGVUaHVua0FjdGlvbnNDcmVhdG9yIiwiZGlzcGF0Y2hTdGFydCIsInN0YXJ0VHlwZSIsImRpc3BhdGNoRmFpbCIsImZhaWxUeXBlIiwiZXJyb3IiLCJkaXNwYXRjaFN1Y2Nlc3MiLCJzdWNjZXNzVHlwZSIsImZhaWx1cmUiLCJfZmFpbHVyZSIsInRodW5rSGFuZGxlciIsInJlc29sdmVkIiwiY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlIiwiX2xBTSIsInNvdXJjZUFjdGlvbiIsIl9hQ0QiLCJiaW5kTGlzdGVuZXJkZWZzIiwibGlzdGVuZXJkZWZzIiwidGFyZ2V0VHlwZXMiLCJ0YXJnZXRUeXBlIiwibGlzdGVuZXJSZWciLCJjcmVhdGVDb21wdXRlZFByb3BlcnR5QmluZGVyIiwiaGFzUnVuT25jZSIsInByZXZJbnB1dHMiLCJwcmV2VmFsdWUiLCJwcmV2U3RvcmVTdGF0ZSIsInBlcmZvcm1pbmdFcXVhbGl0eUNoZWNrIiwiYXJlRXF1YWwiLCJjcmVhdGVDb21wdXRlZFByb3BlcnR5Iiwic3RvcmVTdGF0ZSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsInJlc29sdmVyIiwiX2NTIiwiaXNJblJlZHVjZXIiLCJzdGFjayIsIm1hdGNoIiwibmV3VmFsdWUiLCJjcmVhdGVDb21wdXRlZFByb3BlcnRpZXNNaWRkbGV3YXJlIiwiY3JlYXRlRWZmZWN0c01pZGRsZXdhcmUiLCJfZSIsInByZXZTdGF0ZSIsInByZXZMb2NhbCIsIm5leHRMb2NhbCIsInByZXZEZXBlbmRlbmNpZXMiLCJuZXh0RGVwZW5kZW5jaWVzIiwiaGFzQ2hhbmdlZCIsInNvbWUiLCJkZXBlbmRlbmN5IiwibG9nRWZmZWN0RXJyb3IiLCJjcmVhdGVFZmZlY3RIYW5kbGVyIiwiZGlzcG9zZSIsImNoYW5nZSIsImRpc3Bvc2VSZXN1bHQiLCJhY3Rpb25zIiwiZWZmZWN0UmVzdWx0IiwibG9nRWZmZWN0RXZlbnRMaXN0ZW5lckVycm9yIiwiY3JlYXRlRWZmZWN0QWN0aW9uc0NyZWF0b3IiLCJlZmZlY3RIYW5kbGVyIiwicHJldmlvdXNEZXBlbmRlbmNpZXMiLCJwcmV2IiwiZXh0cmFjdERhdGFGcm9tTW9kZWwiLCJpbml0aWFsU3RhdGUiLCJhY3Rpb25UaHVua3MiLCJfbEFDIiwicmVjdXJzaXZlRXh0cmFjdEZyb21Nb2RlbCIsImhhbmRsZVZhbHVlQXNTdGF0ZSIsImluaXRpYWxQYXJlbnRSZWYiLCJjYXRlZ29yeSIsImpvaW4iLCJfZGVmIiwiX2NhdGVnb3J5IiwiX2RlZjIiLCJfdHlwZSIsImV4aXN0aW5nIiwic29ydCIsImFQYXRoIiwiYlBhdGgiLCJvcHRpb25zIiwibW9kZWxDbG9uZSIsIl9vcHRpb25zIiwiY29tcG9zZSQxIiwiX29wdGlvbnMkZGV2VG9vbHMiLCJkZXZUb29scyIsIl9vcHRpb25zJGRpc2FibGVJbW1lciIsIl9vcHRpb25zJGVuaGFuY2VycyIsImVuaGFuY2VycyIsIl9vcHRpb25zJGluaXRpYWxTdGF0ZSIsIl9vcHRpb25zJGluamVjdGlvbnMiLCJfb3B0aW9ucyRtaWRkbGV3YXJlIiwibWlkZGxld2FyZSIsIl9vcHRpb25zJG1vY2tBY3Rpb25zIiwibW9ja0FjdGlvbnMiLCJfb3B0aW9ucyRuYW1lIiwibmFtZSIsInN0b3JlTmFtZSIsIl9vcHRpb25zJHZlcnNpb24iLCJfb3B0aW9ucyRyZWR1Y2VyRW5oYW4iLCJyZWR1Y2VyRW5oYW5jZXIiLCJiaW5kUmVwbGFjZVN0YXRlIiwibW9kZWxEZWYiLCJlUFJTIiwibW9kZWxkZWYiLCJtb2NrZWRBY3Rpb25zIiwicGVyc2lzdE1pZGRsZXdhcmUiLCJiaW5kU3RvcmVJbnRlcm5hbHMiLCJtb2NrQWN0aW9uc01pZGRsZXdhcmUiLCJkZXZUb29sQ29uZmlnIiwiY29tcG9zZUVuaGFuY2VycyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyIsImVhc3lQZWFzeU1pZGRsZXdhcmUiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhY3Rpb25zS2V5IiwicmViaW5kU3RvcmUiLCJyZW1vdmVLZXkiLCJyZXBsYWNlUmVkdWNlciIsIl9yZXNvbHZlUmVoeWRyYXRpb24iLCJhc3NpZ24iLCJhZGRNb2RlbCIsIm1vZGVsRm9yS2V5IiwicmVtb3ZlTW9kZWwiLCJhZGRNb2RlbFJlaHlkcmF0aW9uIiwiY2xlYXJNb2NrZWRBY3Rpb25zIiwiZ2V0TGlzdGVuZXJzIiwiZ2V0TW9ja2VkQWN0aW9ucyIsInJlY29uZmlndXJlIiwibmV3TW9kZWwiLCJjcmVhdGVDb250ZXh0U3RvcmUiLCJfY29uZmlnIiwiX2NvbmZpZyRpbmplY3Rpb25zIiwibXV0YWJsZUluamVjdGlvbnMiLCJQcm92aWRlciIsImNoaWxkcmVuIiwicnVudGltZU1vZGVsIiwibmV4dEluamVjdGlvbnMiLCJuZXh0S2V5cyIsInJlbW92ZUtleXMiLCJmaWx0ZXIiLCJrIiwiaW5jbHVkZXMiLCJvcmlnaW5hbEluamVjdGlvbnMiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlVHJhbnNmb3JtIiwiaW5ib3VuZCIsIm91dGJvdW5kIiwid2hpdGVsaXN0IiwiYmxhY2tsaXN0Iiwid2hpdGVsaXN0QmxhY2tsaXN0Q2hlY2siLCJpbmRleE9mIiwiX2luIiwiZnVsbFN0YXRlIiwiU3RvcmVQcm92aWRlciIsInVzZUxvY2FsU3RvcmUiLCJtb2RlbENyZWF0b3IiLCJkZXBlbmRlbmNpZXMiLCJjb25maWdDcmVhdG9yIiwic3RvcmVSZWYiLCJjb25maWdSZWYiLCJwcmV2aW91c1N0YXRlIiwiX3N0b3JlIiwic2V0Q3VycmVudFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easy-peasy/dist/index.js\n");

/***/ })

};
;